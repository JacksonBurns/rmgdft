diff ./Common/print_density_z_direction.c ../ultrasoft/./Common/print_density_z_direction.c
2c2
<  **    $Id: print_density_z_direction.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: print_density_z_direction.c 1066 2009-08-31 18:41:09Z froze $    **
57c57
<        MPI_Barrier(pct.grid_comm); */
---
>        MPI_Barrier(pct.thisgrp_comm); */
97c97
<             MPI_Send (temp_buff, pz0_grid, MPI_DOUBLE, 0, 100, pct.grid_comm);
---
>             MPI_Send (temp_buff, pz0_grid, MPI_DOUBLE, 0, 100, pct.thisgrp_comm);
105c105
<             MPI_Recv (temp_buff, pz0_grid, MPI_DOUBLE, MPI_ANY_SOURCE, 100, pct.grid_comm,
---
>             MPI_Recv (temp_buff, pz0_grid, MPI_DOUBLE, MPI_ANY_SOURCE, 100, pct.thisgrp_comm,
116c116
<         MPI_Barrier (pct.grid_comm);
---
>         MPI_Barrier (pct.thisgrp_comm);
Only in ./Common: pulay.c
Only in ../ultrasoft/./Common: pulay_rho.c
diff ./Common/quench.c ../ultrasoft/./Common/quench.c
2c2
<  **    $Id: quench.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: quench.c 1123 2010-05-19 20:03:04Z froze $    **
64c64
<         if (pct.imgpe == 0)
---
>         if (pct.thispe == 0)
Only in ../ultrasoft/./Common: qval.c
Only in ../ultrasoft/./Common: qval_R.c
Only in ../ultrasoft/./Common: radiff.c
Only in ../ultrasoft/./Common: radint1.c
Only in ../ultrasoft/./Common: radint.c
Only in ../ultrasoft/./Common: rand0.c
Only in ../ultrasoft/./Common: ranv.c
Only in ../ultrasoft/./Common: read_data.c
diff ./Common/real_min_all.c ../ultrasoft/./Common/real_min_all.c
2c2
<  **    $Id: real_min_all.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: real_min_all.c 1066 2009-08-31 18:41:09Z froze $    **
52c52
<     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_MIN, pct.grid_comm);
---
>     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_MIN, pct.thisgrp_comm);
diff ./Common/real_sum_all.c ../ultrasoft/./Common/real_sum_all.c
2c2
<  **    $Id: real_sum_all.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: real_sum_all.c 1144 2010-09-24 17:48:57Z froze $    **
55c55
<     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_SUM, pct.grid_comm);
---
>     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_SUM, pct.thisgrp_comm);
69,115c69
< 
< 
< REAL real_sum_all_spin (REAL x)
< {
< 
<     REAL inreg;
<     REAL outreg;
< #if MD_TIMERS
<     REAL time0;
< 
<     time0 = my_crtc ();
< #endif
< 	
< 
< 
<     inreg = x; 
<     
<     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
< 
< #if MD_TIMERS
<     rmg_timings (REAL_SUM_ALL_TIME, my_crtc () - time0, 0);
< #endif
< 
< 
<     return outreg;
< 
< }                               /* end real_sum_all_spin */
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
---
> /******/
Only in ../ultrasoft/./Common: recips.c
diff ./Common/rft1.c ../ultrasoft/./Common/rft1.c
2c2
<  **    $Id: rft1.c 1150 2010-10-08 17:36:21Z froze $    **
---
>  **    $Id: rft1.c 1161 2010-10-26 23:18:51Z froze $    **
diff ./Common/rmg_fastrelax.c ../ultrasoft/./Common/rmg_fastrelax.c
2c2
<  **    $Id: rmg_fastrelax.c 1066 2009-08-31 18:41:09Z froze $    **
---
>  **    $Id: rmg_fastrelax.c 1186 2011-01-15 06:09:45Z miro $    **
58,59c58,63
<         /* Get ionic mass */
<         mass = ct.sp[iptr->species].atomic_mass * mu_me;
---
>         /* Use either actual ionic mass or equal mass for all atoms*/
> 	if (ct.fastrelax_mass == 0)
> 	    mass = ct.sp[iptr->species].atomic_mass * mu_me;
> 	else
> 	    mass =  12.0 * mu_me;
> 	
71,73d74
<         if (dotfv <= 0.1e-12)
<             dotfv /= THREE;
< 
135,136d135
< 
< 
Only in ../ultrasoft/./Common: rmg_semaphores.c
Only in ../ultrasoft/./Common: rmg_timings.c
diff ./Common/salloc.c ../ultrasoft/./Common/salloc.c
2c2
<  **    $Id: salloc.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: salloc.c 1066 2009-08-31 18:41:09Z froze $    **
500c500
<     MPI_Comm_size (pct.grid_comm, &npe);
---
>     MPI_Comm_size (pct.thisgrp_comm, &npe);
diff ./Common/scalapack_tools.c ../ultrasoft/./Common/scalapack_tools.c
2c2
<  **    $Id: scalapack_tools.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: scalapack_tools.c 1220 2011-01-27 23:59:08Z miro $    **
74a75
>     int grp_loop, tmp_ictxt;
109c110,111
<     for (i = 0; (tgmap[i] = i) < NPES; i++);
---
>     for (i = 0; i < NPES; i++)
> 	tgmap[i] = i;
114c116
<     MPI_Comm_group (pct.grid_comm, &grp_this);
---
>     MPI_Comm_group (pct.thisgrp_comm, &grp_this);
138a141
>     my_free (tgmap);
189c192
< void set_desca (int *desca, int *ictxt, int *size)
---
> void set_desca (int *desca, int *ictxt, int size)
194c197
<     mxllda = NUMROC (size, &nb, &pct.scalapack_myrow, &izero, &pct.scalapack_nprow);
---
>     mxllda = NUMROC (&size, &nb, &pct.scalapack_myrow, &izero, &pct.scalapack_nprow);
201c204
<         DESCINIT (desca, size, size, &nb, &nb, &rsrc, &csrc, ictxt, &mxllda, &info);
---
>         DESCINIT (desca, &size, &size, &nb, &nb, &rsrc, &csrc, ictxt, &mxllda, &info);
386,664d388
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< #if 0
< 
< 
< void diaginit (double *aa, int *desca, double *a, int lda)
< {
<     int i, ii, iii, li, maxli, iistart;
<     int mycol, myrow, nprow, npcol;
<     int ictxt = desca[1], mb = desca[4], mxllda = desca[8];
< 
< 
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
<     for (i = 0; i < mxllda * mxllda; i++)
<         aa[i] = 0.;
< 
<     maxli = (lda / (nprow * mb)) + 1;
< 
<     if (myrow == mycol)
<         for (li = 0; li < maxli; li++)
<         {
< 
<             iistart = (li * nprow + myrow) * mb;
< 
<             for (i = 0; i < mb; i++)
<             {
< 
<                 ii = iistart + i;
<                 iii = i + li * mb;
< 
<                 if (iii < mxllda && ii < lda)
<                 {
< 
<                     aa[iii * (mxllda + 1)] = a[ii];
<                 }
< 
<             }
<         }
< 
< }
< 
< 
< /*
< *
< *     MATGATHER generates and distributes matrice a
< *
< */
< 
< 
< void distribute_mat (double *bigmat, double *dismat)
< {
<     int desca[DLEN];
<     int ictxt;
<     int nb = NB, npcol = NPCOL, nprow = NPROW, numst = ct.num_states;
<     int mycol, myrow, mxllda;
<     int rsrc = 0, csrc = 0, info;
< 
< 
<     mxllda = MXLLDA;
<     /* INITIALIZE THE PROCESS GRID */
<     sl_init (&ictxt, NPROW, NPCOL);
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
< 
<     /* If I'm in the process grid, execute the program */
<     if (myrow != -1)
<     {
< 
<         /* DISTRIBUTE THE MATRIX ON THE PROCESS GRID */
<         /* Initialize the array descriptors for the matrices */
<         DESCINIT (desca, &numst, &numst, &nb, &nb, &rsrc, &csrc, &ictxt, &mxllda, &info);
<         if (info != 0)
<         {
<             printf (" distribute_mat: DESCINIT, info=%d\n", info);
<             fflush (NULL);
<             globalexit (0);
<         }
< 
< 
<         matinit (dismat, desca, bigmat, ct.num_states);
< /*
<  *     RELEASE THE PROCESS GRID
<  *     Free the BLACS context
<  */
<         Cblacs_gridexit (ictxt);
< 
<     }
< 
< }
< 
< /********************************************************************/
< 
< /********************************************************************/
< 
< void get_distributed_mat (double *bigmat, double *dismat)
< {
<     int desca[DLEN];
<     int ictxt;
<     int nb = NB, npcol = NPCOL, nprow = NPROW, numst = ct.num_states;
<     int mycol, myrow, mxllda;
<     int rsrc = 0, csrc = 0, info, idx;
<     int n2 = ct.num_states * ct.num_states;
< 
<     mxllda = MXLLDA;
< 
<     /* INITIALIZE THE PROCESS GRID */
<     sl_init (&ictxt, NPROW, NPCOL);
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
< 
<     /* If I'm in the process grid, execute the program */
<     if (myrow != -1)
<     {
< 
<         /* DISTRIBUTE THE MATRIX ON THE PROCESS GRID */
<         /* Initialize the array descriptors for the matrices */
<         DESCINIT (desca, &numst, &numst, &nb, &nb, &rsrc, &csrc, &ictxt, &mxllda, &info);
<         if (info != 0)
<         {
<             printf (" distribute_mat: DESCINIT, info=%d\n", info);
<             fflush (NULL);
<             globalexit (0);
<         }
< 
<         matgather (dismat, desca, bigmat, ct.num_states);
< /*
<  *     RELEASE THE PROCESS GRID
<  *     Free the BLACS context
<  */
<         Cblacs_gridexit (ictxt);
< 
<     }
<     else
<     {
< 
<         for (idx = 0; idx < n2; idx++)
<             bigmat[idx] = 0.;
< 
<     }
< 
< 
< }
< 
< /********************************************************************/
< 
< void dsymm_dis (char *side, char *uplo, int *nn, double *aa, double *bb, double *cc)
< {
<     int desca[DLEN];
<     int ictxt;
<     int nb = NB, npcol = NPCOL, nprow = NPROW;
<     int mycol, myrow, mxllda;
<     int rsrc = 0, csrc = 0, info;
<     _fcd char_fcd1;
<     _fcd char_fcd2;
<     double zero = 0., one = 1.;
<     int ione = 1;
< 
<     mxllda = MXLLDA;
<     /* INITIALIZE THE PROCESS GRID */
<     sl_init (&ictxt, NPROW, NPCOL);
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
< 
<     /* If I'm in the process grid, execute the program */
<     if (myrow != -1)
<     {
< 
<         /* DISTRIBUTE THE MATRIX ON THE PROCESS GRID */
<         /* Initialize the array descriptors for the matrices */
<         DESCINIT (desca, nn, nn, &nb, &nb, &rsrc, &csrc, &ictxt, &mxllda, &info);
<         if (info != 0)
<         {
<             printf (" distribute_mat: DESCINIT, info=%d\n", info);
<             fflush (NULL);
<             globalexit (0);
<         }
< #if CRAY_T3E
<         char_fcd1 = _cptofcd (side, 1);
<         char_fcd2 = _cptofcd (uplo, 1);
< #else
<         char_fcd1 = side;
<         char_fcd2 = uplo;
< #endif
< 
<         PSSYMM (char_fcd1, char_fcd2, nn, nn,
<                 &one, aa, &ione, &ione, desca,
<                 bb, &ione, &ione, desca, &zero, cc, &ione, &ione, desca);
< /*
<  *     RELEASE THE PROCESS GRID
<  *     Free the BLACS context
<  */
<         Cblacs_gridexit (ictxt);
< 
<     }
< 
< 
< }
< 
< 
< 
< #if LINUX
< void PSSYMM (_fcd side_fcd, _fcd uplo_fcd, int *m, int *n, double *alpha,
<              double *a, int *t1, int *t2, int *desca,
<              double *b, int *t3, int *t4, int *descb,
<              double *beta, double *c, int *t5, int *t6, int *descc)
< {
<     int lda = ct.num_states, ldb = ct.num_states, ldc = ct.num_states;
< 
<     dsymm_ (side_fcd, uplo_fcd, m, n, alpha, a, &lda, b, &ldb, beta, c, &ldc);
< 
< }
< #endif
< 
< #endif
Only in ../ultrasoft/./Common: scatter_psi.c
diff ./Common/scf.c ../ultrasoft/./Common/scf.c
2c2
<  **    $Id: scf.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: scf.c 1192 2011-01-20 08:37:16Z miro $    **
52c52
<           REAL * rho,  REAL * rhocore, REAL * rhoc, int *CONVERGENCE)
---
>           REAL * rho, REAL * rhocore, REAL * rhoc, int *CONVERGENCE)
55c55
<     int kpt, st1, idx, ik, st, sttemp;
---
>     int kpt, st1, idx, ik;
57c57
<     REAL *vtot, *vtot_psi ;
---
>     REAL *vtot, *vtot_psi, *new_rho;
60d59
<     MPI_Status status;    
62d60
<     
65a64
>     my_malloc (new_rho, FP0_BASIS, REAL);
69,70d67
< 
< 
76,77c73
<     time1 = my_crtc (); 
<     
---
>     time1 = my_crtc ();
81a78
> 
97d93
< 	dprintf("grid %d: rho %.4e and rhocompen %.4e", idx, rho[idx], rhoc[idx]);
107c103
<     if (pct.imgpe == 0 && !firststep)
---
>     if (pct.thispe == 0 && !firststep)
140a137,139
> 
> 
> 
158d156
<     
160,163c158,160
<     if (!firststep)	
<     {
<     
<     	/* Take care of occupation filling */
---
> 
>     /* Take care of occupation filling */
>     if (!firststep)
165c162
<     }	
---
> 
169c166
<     if (pct.thisimg == 0 && ct.occ_flag == 1 && !firststep)
---
>     if (pct.thispe == 0 && ct.occ_flag == 1 && !firststep)
181c178
<     get_rho (states, rho, rhocore);
---
>     get_new_rho (states, new_rho);
182a180,181
>     /*Takes care of mixing and checks whether the charge density is negative*/
>     mix_rho(new_rho, rho, rhocore, FP0_BASIS, FPX0_GRID, FPY0_GRID, FPZ0_GRID);
192d190
<  
199a198
>     my_free (new_rho);
Only in ../ultrasoft/./Common: set_bc.c
Only in ../ultrasoft/./Common: set_bcx.c
Only in ../ultrasoft/./Common: solv_pois.c
diff ./Common/sortpsi.c ../ultrasoft/./Common/sortpsi.c
2c2
<  **    $Id: sortpsi.c 1066 2009-08-31 18:41:09Z froze $    **
---
>  **    $Id: sortpsi.c 1210 2011-01-25 18:26:02Z froze $    **
85,88d84
< 
< #if UNICOS_T3E
<                 sswap (&n, sp->psiR, &incx, sp1->psiR, &incx);
< #else
93d88
< #endif
diff ./Common/subdiag_gamma.c ../ultrasoft/./Common/subdiag_gamma.c
2c2
<  **    $Id: subdiag_gamma.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: subdiag_gamma.c 1183 2011-01-14 11:03:31Z miro $    **
51d50
< #include "my_scalapack.h"
69,71d67
< #if PULAY
< REAL *global_matrix=NULL;
< #endif
95c91,92
<     int idx, st1, num_states;
---
>     int idx, st1;
> 	int num_states;
104d100
< #if !PULAY
106d101
< #endif
113,114c108
<     int ictxt;
<     int desca[DLEN], dist_length, dist_stop, pbasis;
---
> 	int dist_length, dist_stop, pbasis;
137,143d130
< #if PULAY
<     if (global_matrix == NULL) my_calloc (global_matrix, stop, REAL);
<     else {
< 	for (idx = 0; idx < stop; idx++)
< 	    global_matrix[idx] = 0.0;
<     }
< #else
145d131
< #endif
174,183d159
<     /*Initialize ScaLapack, get context */
<     sl_init (&ictxt, num_states);
< 
< 
<     /*Set desca, variable used in ScaLapack functions */
<     set_desca (desca, &ictxt, &num_states);
< 
< 
< 
< 
189,190c165,166
<             NUMROC (&num_states, &desca[4], &pct.scalapack_myrow, &izero,
<                     &pct.scalapack_nprow) * NUMROC (&num_states, &desca[4], &pct.scalapack_mycol,
---
>             NUMROC (&num_states, &pct.desca[4], &pct.scalapack_myrow, &izero,
>                     &pct.scalapack_nprow) * NUMROC (&num_states, &pct.desca[4], &pct.scalapack_mycol,
256c232
<             distribute_mat (desca, global_matrix, distAij, &num_states);
---
>             distribute_mat (pct.desca, global_matrix, distAij, &num_states);
294c270
<             distribute_mat (desca, global_matrix, distSij, &num_states);
---
>             distribute_mat (pct.desca, global_matrix, distSij, &num_states);
331c307
<             distribute_mat (desca, global_matrix, distBij, &num_states);
---
>             distribute_mat (pct.desca, global_matrix, distBij, &num_states);
361c337
<         distribute_mat (desca, global_matrix, distCij, &num_states);
---
>         distribute_mat (pct.desca, global_matrix, distCij, &num_states);
387c363
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
397,398c373,374
<                 NUMROC (&desca[2], &desca[4], &pct.scalapack_myrow, &desca[6],
<                         &pct.scalapack_nprow) + desca[4];
---
>                 NUMROC (&pct.desca[2], &pct.desca[4], &pct.scalapack_myrow, &pct.desca[6],
>                         &pct.scalapack_nprow) + pct.desca[4];
403,404c379,380
<             PDGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PDGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
406,407c382,383
<             PZGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PZGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
422c398
<         print_dist_matrix (distCij, num_states, desca);
---
>         print_dist_matrix (distCij, num_states, pct.desca);
435,436c411,412
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
439,440c415,416
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
446c422
<             print_dist_matrix (distBij, num_states, desca);
---
>             print_dist_matrix (distBij, num_states, pct.desca);
453,454c429,430
<                     distSij, &ione, &ione, desca, distBij, &ione, &ione, desca, beta, distCij,
<                     &ione, &ione, desca);
---
>                     distSij, &ione, &ione, pct.desca, distBij, &ione, &ione, pct.desca, beta, distCij,
>                     &ione, &ione, pct.desca);
457,458c433,434
<                     distSij, &ione, &ione, desca, distBij, &ione, &ione, desca, beta, distCij,
<                     &ione, &ione, desca);
---
>                     distSij, &ione, &ione, pct.desca, distBij, &ione, &ione, pct.desca, beta, distCij,
>                     &ione, &ione, pct.desca);
469c445
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
496,498c472,474
<             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, desca,
<                      distSij, &ione, &ione, desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
<                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, desca, &lwork_tmp, &lwork,
---
>             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, pct.desca,
>                      distSij, &ione, &ione, pct.desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
>                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, pct.desca, &lwork_tmp, &lwork,
519,521c495,497
<             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, desca,
<                      distSij, &ione, &ione, desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
<                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, desca, work2, &lwork, iwork,
---
>             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, pct.desca,
>                      distSij, &ione, &ione, pct.desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
>                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, pct.desca, work2, &lwork, iwork,
550c526
<         matgather (distAij, desca, global_matrix, num_states);
---
>         matgather (distAij, pct.desca, global_matrix, num_states);
562,564d537
<         /*Exit Scalapack */
<         sl_exit (ictxt);
< 
594c567
<         MPI_Bcast (eigs, num_states, MPI_DOUBLE, 0, pct.grid_comm);
---
>         MPI_Bcast (eigs, num_states, MPI_DOUBLE, 0, pct.thisgrp_comm);
630d602
< #if !PULAY
632d603
< #endif
diff ./Common/subdiag_nongamma.c ../ultrasoft/./Common/subdiag_nongamma.c
2c2
<  **    $Id: subdiag_nongamma.c 1134 2010-08-18 08:40:51Z miro $    **
---
>  **    $Id: subdiag_nongamma.c 1163 2010-11-03 19:43:40Z froze $    **
80c80,81
<     int idx, st1, num_states;
---
>     int idx, st1;
> 	int num_states = pct.size;
92,93c93
<     int ictxt;
<     int desca[DLEN], dist_length, dist_stop;
---
>     int dist_length, dist_stop;
183,188d182
<     /*Initialize ScaLapack, get context */
<     sl_init (&ictxt, num_states);
< 
< 
<     /*Set desca, variable used in ScaLapack functions */
<     set_desca (desca, &ictxt, &num_states);
198,199c192,193
<             NUMROC (&num_states, &desca[4], &pct.scalapack_myrow, &izero,
<                     &pct.scalapack_nprow) * NUMROC (&num_states, &desca[4], &pct.scalapack_mycol,
---
>             NUMROC (&num_states, &pct.desca[4], &pct.scalapack_myrow, &izero,
>                     &pct.scalapack_nprow) * NUMROC (&num_states, &pct.desca[4], &pct.scalapack_mycol,
225,227c219,221
<         distribute_mat (desca, Aij, distAij, &num_states);
<         distribute_mat (desca, Bij, distBij, &num_states);
<         distribute_mat (desca, Cij, distCij, &num_states);
---
>         distribute_mat (pct.desca, Aij, distAij, &num_states);
>         distribute_mat (pct.desca, Bij, distBij, &num_states);
>         distribute_mat (pct.desca, Cij, distCij, &num_states);
236c230
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
244c238
<         print_dist_matrix (distBij, num_states, desca);
---
>         print_dist_matrix (distBij, num_states, pct.desca);
248c242
<         print_dist_matrix (distAij, num_states, desca);
---
>         print_dist_matrix (distAij, num_states, pct.desca);
257,258c251,252
<                 NUMROC (&desca[2], &desca[4], &pct.scalapack_myrow, &desca[6],
<                         &pct.scalapack_nprow) + desca[4];
---
>                 NUMROC (&pct.desca[2], &pct.desca[4], &pct.scalapack_myrow, &pct.desca[6],
>                         &pct.scalapack_nprow) + pct.desca[4];
263,264c257,258
<             PDGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PDGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
266,267c260,261
<             PZGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PZGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
282c276
<         print_dist_matrix (distCij, num_states, desca);
---
>         print_dist_matrix (distCij, num_states, pct.desca);
295,296c289,290
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
299,300c293,294
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
306c300
<             print_dist_matrix (distBij, num_states, desca);
---
>             print_dist_matrix (distBij, num_states, pct.desca);
314c308
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
329,330c323,324
<             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, t1, &lwork, &info);
---
>             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, t1, &lwork, &info);
332,333c326,327
<             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, t1, &lwork, t2, &lrwork, &info);
---
>             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, t1, &lwork, t2, &lrwork, &info);
344,345c338,339
<             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, work2, &lwork, &info);
---
>             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, work2, &lwork, &info);
350,351c344,345
<             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, work2, &lwork, work3, &lrwork, &info);
---
>             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, work2, &lwork, work3, &lrwork, &info);
367c361
<         matgather (distAij, desca, Aij, num_states);
---
>         matgather (distAij, pct.desca, Aij, num_states);
377,379d370
< 
<         /*Exit Scalapack */
<         sl_exit (ictxt);
Common subdirectories: ./Common/.svn and ../ultrasoft/./Common/.svn
Only in ../ultrasoft/./Common: symmetry.c
Only in ../ultrasoft/./Common: threads.c
Only in ../ultrasoft/./Common: to_cartesian.c
Only in ../ultrasoft/./Common: to_crystal.c
diff ./Common/trade_images.c ../ultrasoft/./Common/trade_images.c
2c2
<  **    $Id: trade_images.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: trade_images.c 1066 2009-08-31 18:41:09Z froze $    **
93c93
<                   MPI_DOUBLE, nb_ids[NB_D], 1, pct.grid_comm, &mstatus);
---
>                   MPI_DOUBLE, nb_ids[NB_D], 1, pct.thisgrp_comm, &mstatus);
119c119
<                   MPI_DOUBLE, nb_ids[NB_U], 1, pct.grid_comm, &mstatus);
---
>                   MPI_DOUBLE, nb_ids[NB_U], 1, pct.thisgrp_comm, &mstatus);
140c140
<                   newtype, nb_ids[NB_S], 3, pct.grid_comm, &mstatus);
---
>                   newtype, nb_ids[NB_S], 3, pct.thisgrp_comm, &mstatus);
142c142
<                   newtype, nb_ids[NB_N], 4, pct.grid_comm, &mstatus);
---
>                   newtype, nb_ids[NB_N], 4, pct.thisgrp_comm, &mstatus);
154c154
<                   mat, stop, MPI_DOUBLE, nb_ids[NB_W], 5, pct.grid_comm, &mstatus);
---
>                   mat, stop, MPI_DOUBLE, nb_ids[NB_W], 5, pct.thisgrp_comm, &mstatus);
156c156
<                   &mat[xmax + incx], stop, MPI_DOUBLE, nb_ids[NB_E], 6, pct.grid_comm, &mstatus);
---
>                   &mat[xmax + incx], stop, MPI_DOUBLE, nb_ids[NB_E], 6, pct.thisgrp_comm, &mstatus);
Only in ./Common: trade_imagesx.c
Only in ../ultrasoft/./Common: update_waves.c
Only in ../ultrasoft/./Common: write_avgd.c
Only in ../ultrasoft/./Common: write_avgv.c
diff ./Common/write_data.c ../ultrasoft/./Common/write_data.c
2c2
<  **    $Id: write_data.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: write_data.c 1161 2010-10-26 23:18:51Z froze $    **
86c86
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
93c93
<         if (pct.imgpe == 0)
---
>         if (pct.thispe == 0)
109a110,111
>         if (pct.thispe == 0)
>             printf ("write_data: Wavefile %s opened...\n", name);
255c257
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
Only in ../ultrasoft/./Common: write_force.c
diff ./Common/write_header.c ../ultrasoft/./Common/write_header.c
2c2
<  **    $Id: write_header.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: write_header.c 1161 2010-10-26 23:18:51Z froze $    **
231,242c231
< 
<     if (pct.spin_flag)
<     {
<     	printf ("    This is a spin polarized calculation \n");
<     	printf ("    Number of spin up states   = %d\n", ct.num_states);
<     	printf ("    Number of spin down states   = %d\n", ct.num_states_oppo);
<     }
<     else
<     {
<     	printf ("    This is NOT a spin polarized calculation \n");
<     	printf ("    Number of states   = %d\n", ct.num_states);
<     }	
---
>     printf ("    Number of states   = %d\n", ct.num_states);
355,359c344,348
<             printf ("       % 10f % 10f % 10f %d\n",
< 					ct.ions[idx].constraint[0],
< 					ct.ions[idx].constraint[1],
< 					ct.ions[idx].constraint[2],
<                     ct.ions[idx].constraint_type);
---
>             printf ("       % 10f % 10f % 10f % 10f\n",
> 					ct.ions[idx].constraint.setA_coord[0],
> 					ct.ions[idx].constraint.setA_coord[1],
> 					ct.ions[idx].constraint.setA_coord[2],
>                     ct.ions[idx].constraint.setA_weight);
404c393
<     if ((pct.imgpe == 0) && (verify ("pdb_atoms", NULL)))
---
>     if ((pct.thispe == 0) && (verify ("pdb_atoms", NULL)))
diff ./Common/write_occ.c ../ultrasoft/./Common/write_occ.c
2c2
<  **    $Id: write_occ.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: write_occ.c 1066 2009-08-31 18:41:09Z froze $    **
65,68d64
<     
<     if (pct.spin_flag)
<     {
< 	printf ("\n\n  STATE OCCUPATIONS for spin up:\n");
70,81c66
<     	for (i = 0; i < ct.num_states; i++)
<         	printf (" %7.2f%s", states[i].occupation, ((i % 10 == 9) ? "\n" : ""));
< 	
< 	printf ("\n\n  STATE OCCUPATIONS for spin down:\n");
< 
<     	for (i = 0; i < ct.num_states_oppo; i++)
<         	printf (" %7.2f%s", states[i].occupation_oppo, ((i % 10 == 9) ? "\n" : ""));
< 	printf ("\n");
<     }  
<     else 
<     {
< 	printf ("\n\n  STATE OCCUPATIONS :\n");
---
>     printf ("\n\n  STATE OCCUPATIONS:\n");
83,85c68,69
<     	for (i = 0; i < ct.num_states; i++)
<         	printf (" %7.2f%s", states[i].occupation, ((i % 10 == 9) ? "\n" : ""));
< 	printf ("\n");
---
>     for (i = 0; i < ct.num_states; i++)
>         printf (" %7.2f%s", states[i].occupation, ((i % 10 == 9) ? "\n" : ""));
87c71
<     }
---
>     printf ("\n");
Only in ../ultrasoft/./Common: write_pdb.c
Only in ../ultrasoft/./Common: write_zstates.c
diff ./Common/wvfn_residual.c ../ultrasoft/./Common/wvfn_residual.c
2c2
<  **    $Id: wvfn_residual.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: wvfn_residual.c 1066 2009-08-31 18:41:09Z froze $    **
52,53d51
< 
< 
Only in ../ultrasoft/./Common: xbsmovie.c
diff ./Common/xcgga.c ../ultrasoft/./Common/xcgga.c
2c2
<  **    $Id: xcgga.c 1146 2010-09-29 17:43:50Z btan $    **
---
>  **    $Id: xcgga.c 1161 2010-10-26 23:18:51Z froze $    **
47c47
< #define    SMALL  1.e-10
---
> #define    SMALL  1.e-8
52,56c52,63
<     int ix, iy, iz, idx, iflag;
<     FP0_GRID *gx, *gy, *gz, *vgx, *vgy, *vgz, *agg, *d2rho;
<     REAL d, grad, vxc1, vxc2[FP0_BASIS], enxc;
<     REAL kf, pisq3, ex, vx, ec, vc, rs;
< 
---
> #if 1
>     int ix, iy, iz, idx;
>     FP0_GRID *gx, *gy, *gz, *agx, *agy, *agz, *agg, *d2rho;
>     REAL d, s, u, v, kf, us, uu, t, vv, ww;
>     REAL pisq3, ex, vx, ec;
>     REAL zet, rs, g, h, sk, gks2;
>     REAL vcup, vcdn;
>     REAL dvcup, dvcdn;
>     REAL ecrs, eczet, alfc;
>     REAL cpot, cen, xen;
>     REAL dhalf, d1half[3], d2half, vcm0, fac;
>     int ndim = 3, lgga, lpot;
65,67c72,74
<     my_malloc (vgx, 1, FP0_GRID);
<     my_malloc (vgy, 1, FP0_GRID);
<     my_malloc (vgz, 1, FP0_GRID);
---
>     my_malloc (agx, 1, FP0_GRID);
>     my_malloc (agy, 1, FP0_GRID);
>     my_malloc (agz, 1, FP0_GRID);
93,94c100,108
<     
<     /* The LDA part of exchange correlation potential and energy */
---
> 
> 
> 
>     /* Get its gradient */
>     app_gradf (agg->s2, agx, agy, agz);
> 
> 
> 
>     /* Now get the potential */
97,105c111,182
< 	    d = fabs (rho[idx]);
< 	    if (d < SMALL && ct.scf_steps < 10)
< 	    {
< 		    vxc[idx] = 0.0;
< 		    exc[idx] = 0.0;
< 		    continue;
< 	    }
<             
< 	    kf = pow (pisq3 * d, 0.333333333333333);
---
> 
>         if ((d=rho[idx]) < SMALL && ct.scf_steps < 10)
>         {
>             d = SMALL;
>             fac = exp (50. * (rho[idx] / d - 1.0));
>         }
>         else
>         {
>             fac = 1.0;
>         }
>         //kf = pow (pisq3 * d, 0.333333333333333);
>         kf = cbrt (pisq3 * d);
> 
>         s = agg->s2[idx] / (TWO * kf * d);
>         us = gx->s2[idx] * agx->s2[idx] + gy->s2[idx] * agy->s2[idx] + gz->s2[idx] * agz->s2[idx];
>         /* 
>            us = agg->s2[idx] * d2rho->s2[idx];
>          */
> 
>         u = us / (d * d * EIGHT * kf * kf * kf);
> 
>         v = d2rho->s2[idx] / (FOUR * d * kf * kf);
> 
>         if (mode == GGA_BLYP || mode == GGA_XB_CP)
>         {
> 
>             /* Exchange potential from becke */
>             xbecke (&d, &s, &u, &v, &ex, &vx);
> 
>         }
>         else if (mode == GGA_PBE)
>         {
> 
>             /* exchange potential from Perdew, Burke, Ernzerhof */
>             lpot = 1;
>             lgga = 1;
>             exchpbe (&d, &s, &u, &v, &lpot, &lgga, &ex, &vx);
>         }
>         else if (mode == GGA_XP_CP)
>         {
> 
>             /* Exchange potential from Perdew */
>             exch (&d, &s, &u, &v, &ex, &vx);
> 
>         }                       /* end if */
> 
> 
>         if (mode == GGA_BLYP)
>         {
>             if ((d = rho[idx]) < 1.e-15)
>             {
>                 cen = 0.0;
>                 cpot = 0.0;
>             }
>             else
>             {
>                 if (d < SMALL)
>                     d = SMALL;
>                 dhalf = d / 2.0;
>                 d1half[0] = gx->s2[idx] / 2.0;
>                 d1half[1] = gy->s2[idx] / 2.0;
>                 d1half[2] = gz->s2[idx] / 2.0;
>                 d2half = d2rho->s2[idx] / 2.0;
>                 corlyp (&dhalf, &dhalf, d1half, d1half, &d2half, &d2half, &cen, &cpot, &vcm0,
>                         &ndim);
>             }
>             vxc[idx] = fac * (cpot + vx);
>             exc[idx] = fac * (cen + ex);
>         }
>         else if (mode == GGA_PBE)
>         {
>             zet = ZERO;         /* Spin up = spin down */
107,135c184,211
< 	    
< 	    /* to determine which set of monte carlo parameter to use for certain xc functionals */
< 	    iflag = 0;           
< 	   
< 	    if (mode == GGA_PBE)
< 	    {
< 	            /* exchange potential and energy */
<                     slater (rs, &ex, &vx); 
< 	
< 	            /* correlation potential and energy */
< 	            pw (rs, iflag , &ec, &vc);
< 	    }
< 	    else if (mode == GGA_XB_CP)
< 	    {
<                     slater (rs, &ex, &vx); 
< 	            
< 		    pz (rs, iflag , &ec, &vc);
< 	    }
< 	    else if (mode == GGA_XP_CP)
< 	    {
<                     slater (rs, &ex, &vx); 
< 	
< 	            pw (rs, iflag , &ec, &vc);
< 	    }
< 	    else if (mode == GGA_BLYP)
< 	    {
<                     slater (rs, &ex, &vx); 
< 	
< 	            lyp (rs, &ec, &vc);
---
>             sk = TWO * sqrt (kf / PI);
> 
>             g = ONE;
> 
>             gks2 = TWO * sk * g;
> 
> 
>             t = agg->s2[idx] / (d * gks2);
>             uu = us / (d * d * gks2 * gks2 * gks2);
>             vv = d2rho->s2[idx] / (d * gks2 * gks2);
>             ww = ZERO;          /* Non-spin polarized case */
> 
>             lpot = 1;
>             lgga = 1;
>             corpbe (&rs, &zet, &t, &uu, &vv, &ww, &lgga, &lpot, &ec, &vcup, &vcdn,
>                     &h, &dvcup, &dvcdn);
> 
>             cpot = vcup + dvcup;
>             cen = ec + h;
> 
>             vxc[idx] = cpot + vx;
>             exc[idx] = cen + ex;
>             
> 	    if (d < 1.e-12)
> 	    { 
> 		    vxc[idx] = mu_pz(d);
> 		    exc[idx] = e_pz(d);
> 
137,143d212
< 	    
< 	   
< 	    /* local density approximation contribution to xc potential and energy */
< 	    vxc[idx] = vc + vx;  
<             exc[idx] = ex + ec;
< 	    
<     }                             /* end for */
145c214,220
<     
---
>         }
>         else
>         {
>             /* LSD contribution to correlation */
>             zet = ZERO;         /* Spin up = spin down */
>             rs = crs / kf;
>             corlsd (&rs, &zet, &ec, &vcup, &vcdn, &ecrs, &eczet, &alfc);
147,209d221
<     /* add the gradient correction for exchange correlation potential and energy */
<     for (idx = 0; idx < FP0_BASIS; idx++)
<     {
< 	
< 	d = rho[idx];
< 	grad = agg->s2[idx]; 
< 
<         if (mode == GGA_PBE)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxcpbe (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 
< 		     /* add the gradient correction to xc potential and energy now */
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;    /* first term of gradient correction to potential*/
< 	     }	     
<         }
< 	else if (mode == GGA_XB_CP)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxbcp (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;
< 	     }	     
<         }
< 	else if (mode == GGA_XP_CP)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxcpw91 (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;
< 	     }	     
<         }
< 	else if (mode == GGA_BLYP)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxcblyp (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;
< 	     }	     
<         }
< 
<     }                           /* end for */ 
210a223
>             sk = TWO * sqrt (kf / PI);
211a225,231
> #if 0
>             /* commented out for speed since we are doing spin-unpolarized calculations */
>             g = pow (1.0 + zet, 0.6666666666666666);
>             g += pow (1.0 - zet, 0.6666666666666666);
>             g = g / TWO;
> #endif
>             g = ONE;
213,214c233
<     /* Get gradient of vxc2 */
<     app_gradf (vxc2, vgx, vgy, vgz);
---
>             gks2 = TWO * sk * g;
217,225c236,245
<      /* add the second term gradient correction to xc potential */
<     for (idx = 0; idx < FP0_BASIS; idx++)
<     {
< 	     vxc[idx] += ( vgx->s2[idx] * gx->s2[idx] + 
< 	     		   vgy->s2[idx] * gy->s2[idx] + vgz->s2[idx] * gz->s2[idx] ) ;
< 	     vxc[idx] += vxc2[idx] * d2rho->s2[idx];
<     }
<    
<     
---
>             t = agg->s2[idx] / (d * gks2);
>             uu = us / (d * d * gks2 * gks2 * gks2);
>             vv = d2rho->s2[idx] / (d * gks2 * gks2);
>             ww = ZERO;          /* Non-spin polarized case */
> 
>             corgga (&rs, &zet, &t, &uu, &vv, &ww, &h, &dvcup, &dvcdn, &kf, &sk,
>                     &g, &ec, &ecrs, &eczet);
> 
>             cpot = vcup + dvcup;
>             cen = ec + h;
226a247,248
>             vxc[idx] = cpot + vx;
>             exc[idx] = cen + ex;
228c250,252
<     
---
>         }
> 
>     }                           /* end for */
237,239c261,263
<     my_free (vgz);
<     my_free (vgy);
<     my_free (vgx);
---
>     my_free (agz);
>     my_free (agy);
>     my_free (agx);
242a267
> #endif
Only in ../ultrasoft/./Common: xclda_pz81.c
Only in ../ultrasoft/./Common: ylm.c
Only in ../ultrasoft/./Common: ylmr2.c
Only in ../ultrasoft/./Common: ylmr2_x.c
Only in ../ultrasoft/./Common: ylmr2_y.c
Only in ../ultrasoft/./Common: ylmr2_z.c
2c2
<  **    $Id: norm_psi1.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: norm_psi1.c 1066 2009-08-31 18:41:09Z froze $    **
86,87c86
<     
<     /*sumpsi = real_sum_all (sumpsi);*/
---
> 
2c2
<  **    $Id: init_states.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: init_states.c 1066 2009-08-31 18:41:09Z froze $    **
166c166
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
2c2
<  **    $Id: global_sums.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: global_sums.c 1220 2011-01-27 23:59:08Z miro $    **
41,46d40
< #  if (LINUX || XT3)
< void global_sums__ (REAL * vect, int *length)
< {
<     global_sums (vect, length);
< }
< #  endif
66,68c60
<        	MPI_Allreduce (rptr2, vect, sizr, MPI_DOUBLE, MPI_SUM, pct.grid_comm);
< 
< 		
---
>         MPI_Allreduce (rptr2, vect, sizr, MPI_DOUBLE, MPI_SUM, pct.thisgrp_comm);
85c77
<         MPI_Allreduce (rptr, rptr1, newsize, MPI_DOUBLE, MPI_SUM, pct.grid_comm);  /* sum over all processors in a cpugrid*/
---
>         MPI_Allreduce (rptr, rptr1, newsize, MPI_DOUBLE, MPI_SUM, pct.thisgrp_comm);
93c85
<         MPI_Allreduce (rptr, rptr1, sizr, MPI_DOUBLE, MPI_SUM, pct.grid_comm);
---
>         MPI_Allreduce (rptr, rptr1, sizr, MPI_DOUBLE, MPI_SUM, pct.thisgrp_comm);
107,112d98
< 
< #  if (LINUX || XT3)
< void global_sums__ (REAL * vect, int *length)
< {
< }
< #  endif
2c2
<  **    $Id: open_wave_file.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: open_wave_file.c 1066 2009-08-31 18:41:09Z froze $    **
31,41c31
< 
<     if (pct.spin_flag)
<     {   
< 	if (pct.thisspin==0)
<     		sprintf (newname, "%s.up%d", filename, pct.thispe);
< 	else if(pct.thisspin==1) 
<     		sprintf (newname, "%s.dw%d", filename, pct.thispe);
< 		
<     }
<     else
<     	sprintf (newname, "%s%d", filename, pct.thispe);
---
>     sprintf (newname, "%s%d", filename, pct.thispe);
48c38
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
80,81c70,71
<     //my_barrier ();
<     MPI_Barrier(MPI_COMM_WORLD);
---
>     my_barrier ();
> 
84c74
<     if (pct.imgpe)
---
>     if (pct.thispe)
2c2
<  **    $Id: scalapack_tools.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: scalapack_tools.c 1220 2011-01-27 23:59:08Z miro $    **
74a75
>     int grp_loop, tmp_ictxt;
109c110,111
<     for (i = 0; (tgmap[i] = i) < NPES; i++);
---
>     for (i = 0; i < NPES; i++)
> 	tgmap[i] = i;
114c116
<     MPI_Comm_group (pct.grid_comm, &grp_this);
---
>     MPI_Comm_group (pct.thisgrp_comm, &grp_this);
138a141
>     my_free (tgmap);
189c192
< void set_desca (int *desca, int *ictxt, int *size)
---
> void set_desca (int *desca, int *ictxt, int size)
194c197
<     mxllda = NUMROC (size, &nb, &pct.scalapack_myrow, &izero, &pct.scalapack_nprow);
---
>     mxllda = NUMROC (&size, &nb, &pct.scalapack_myrow, &izero, &pct.scalapack_nprow);
201c204
<         DESCINIT (desca, size, size, &nb, &nb, &rsrc, &csrc, ictxt, &mxllda, &info);
---
>         DESCINIT (desca, &size, &size, &nb, &nb, &rsrc, &csrc, ictxt, &mxllda, &info);
386,664d388
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< #if 0
< 
< 
< void diaginit (double *aa, int *desca, double *a, int lda)
< {
<     int i, ii, iii, li, maxli, iistart;
<     int mycol, myrow, nprow, npcol;
<     int ictxt = desca[1], mb = desca[4], mxllda = desca[8];
< 
< 
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
<     for (i = 0; i < mxllda * mxllda; i++)
<         aa[i] = 0.;
< 
<     maxli = (lda / (nprow * mb)) + 1;
< 
<     if (myrow == mycol)
<         for (li = 0; li < maxli; li++)
<         {
< 
<             iistart = (li * nprow + myrow) * mb;
< 
<             for (i = 0; i < mb; i++)
<             {
< 
<                 ii = iistart + i;
<                 iii = i + li * mb;
< 
<                 if (iii < mxllda && ii < lda)
<                 {
< 
<                     aa[iii * (mxllda + 1)] = a[ii];
<                 }
< 
<             }
<         }
< 
< }
< 
< 
< /*
< *
< *     MATGATHER generates and distributes matrice a
< *
< */
< 
< 
< void distribute_mat (double *bigmat, double *dismat)
< {
<     int desca[DLEN];
<     int ictxt;
<     int nb = NB, npcol = NPCOL, nprow = NPROW, numst = ct.num_states;
<     int mycol, myrow, mxllda;
<     int rsrc = 0, csrc = 0, info;
< 
< 
<     mxllda = MXLLDA;
<     /* INITIALIZE THE PROCESS GRID */
<     sl_init (&ictxt, NPROW, NPCOL);
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
< 
<     /* If I'm in the process grid, execute the program */
<     if (myrow != -1)
<     {
< 
<         /* DISTRIBUTE THE MATRIX ON THE PROCESS GRID */
<         /* Initialize the array descriptors for the matrices */
<         DESCINIT (desca, &numst, &numst, &nb, &nb, &rsrc, &csrc, &ictxt, &mxllda, &info);
<         if (info != 0)
<         {
<             printf (" distribute_mat: DESCINIT, info=%d\n", info);
<             fflush (NULL);
<             globalexit (0);
<         }
< 
< 
<         matinit (dismat, desca, bigmat, ct.num_states);
< /*
<  *     RELEASE THE PROCESS GRID
<  *     Free the BLACS context
<  */
<         Cblacs_gridexit (ictxt);
< 
<     }
< 
< }
< 
< /********************************************************************/
< 
< /********************************************************************/
< 
< void get_distributed_mat (double *bigmat, double *dismat)
< {
<     int desca[DLEN];
<     int ictxt;
<     int nb = NB, npcol = NPCOL, nprow = NPROW, numst = ct.num_states;
<     int mycol, myrow, mxllda;
<     int rsrc = 0, csrc = 0, info, idx;
<     int n2 = ct.num_states * ct.num_states;
< 
<     mxllda = MXLLDA;
< 
<     /* INITIALIZE THE PROCESS GRID */
<     sl_init (&ictxt, NPROW, NPCOL);
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
< 
<     /* If I'm in the process grid, execute the program */
<     if (myrow != -1)
<     {
< 
<         /* DISTRIBUTE THE MATRIX ON THE PROCESS GRID */
<         /* Initialize the array descriptors for the matrices */
<         DESCINIT (desca, &numst, &numst, &nb, &nb, &rsrc, &csrc, &ictxt, &mxllda, &info);
<         if (info != 0)
<         {
<             printf (" distribute_mat: DESCINIT, info=%d\n", info);
<             fflush (NULL);
<             globalexit (0);
<         }
< 
<         matgather (dismat, desca, bigmat, ct.num_states);
< /*
<  *     RELEASE THE PROCESS GRID
<  *     Free the BLACS context
<  */
<         Cblacs_gridexit (ictxt);
< 
<     }
<     else
<     {
< 
<         for (idx = 0; idx < n2; idx++)
<             bigmat[idx] = 0.;
< 
<     }
< 
< 
< }
< 
< /********************************************************************/
< 
< void dsymm_dis (char *side, char *uplo, int *nn, double *aa, double *bb, double *cc)
< {
<     int desca[DLEN];
<     int ictxt;
<     int nb = NB, npcol = NPCOL, nprow = NPROW;
<     int mycol, myrow, mxllda;
<     int rsrc = 0, csrc = 0, info;
<     _fcd char_fcd1;
<     _fcd char_fcd2;
<     double zero = 0., one = 1.;
<     int ione = 1;
< 
<     mxllda = MXLLDA;
<     /* INITIALIZE THE PROCESS GRID */
<     sl_init (&ictxt, NPROW, NPCOL);
< 
<     Cblacs_gridinfo (ictxt, &nprow, &npcol, &myrow, &mycol);
< 
< 
<     /* If I'm in the process grid, execute the program */
<     if (myrow != -1)
<     {
< 
<         /* DISTRIBUTE THE MATRIX ON THE PROCESS GRID */
<         /* Initialize the array descriptors for the matrices */
<         DESCINIT (desca, nn, nn, &nb, &nb, &rsrc, &csrc, &ictxt, &mxllda, &info);
<         if (info != 0)
<         {
<             printf (" distribute_mat: DESCINIT, info=%d\n", info);
<             fflush (NULL);
<             globalexit (0);
<         }
< #if CRAY_T3E
<         char_fcd1 = _cptofcd (side, 1);
<         char_fcd2 = _cptofcd (uplo, 1);
< #else
<         char_fcd1 = side;
<         char_fcd2 = uplo;
< #endif
< 
<         PSSYMM (char_fcd1, char_fcd2, nn, nn,
<                 &one, aa, &ione, &ione, desca,
<                 bb, &ione, &ione, desca, &zero, cc, &ione, &ione, desca);
< /*
<  *     RELEASE THE PROCESS GRID
<  *     Free the BLACS context
<  */
<         Cblacs_gridexit (ictxt);
< 
<     }
< 
< 
< }
< 
< 
< 
< #if LINUX
< void PSSYMM (_fcd side_fcd, _fcd uplo_fcd, int *m, int *n, double *alpha,
<              double *a, int *t1, int *t2, int *desca,
<              double *b, int *t3, int *t4, int *descb,
<              double *beta, double *c, int *t5, int *t6, int *descc)
< {
<     int lda = ct.num_states, ldb = ct.num_states, ldc = ct.num_states;
< 
<     dsymm_ (side_fcd, uplo_fcd, m, n, alpha, a, &lda, b, &ldb, beta, c, &ldc);
< 
< }
< #endif
< 
< #endif
2c2
<  **    $Id: salloc.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: salloc.c 1066 2009-08-31 18:41:09Z froze $    **
500c500
<     MPI_Comm_size (pct.grid_comm, &npe);
---
>     MPI_Comm_size (pct.thisgrp_comm, &npe);
2c2
<  **    $Id: wvfn_residual.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: wvfn_residual.c 1066 2009-08-31 18:41:09Z froze $    **
52,53d51
< 
< 
2,3c2,3
<  **    $Id: constrain.c 1131 2010-06-28 23:02:22Z froze $    **
< ******************************************************************************/
---
>  **    $Id: constrain.c 1161 2010-10-26 23:18:51Z froze $    **
>  ******************************************************************************/
10c10
< *                      Frisco Rose, Jerzy Bernholc
---
>  *                      Frisco Rose, Jerzy Bernholc
29a30,33
> #define X 0
> #define Y 1
> #define Z 2
> 
34c38
< void constrain (ION * iptr)
---
> void constrain ()
36d39
<     int fpt = ct.fpt[0];
38,57c41,145
<     REAL fdotc =
<         iptr->force[fpt][0] * iptr->constraint[0] +
<         iptr->force[fpt][1] * iptr->constraint[1] +
<         iptr->force[fpt][2] * iptr->constraint[2];
< 
<     switch (iptr->constraint_type)
<     {
<     case 2:                    /* Along vector, 1-D restriction (non-standard) */
<         iptr->force[fpt][0] = fdotc * iptr->constraint[0];
<         iptr->force[fpt][1] = fdotc * iptr->constraint[1];
<         iptr->force[fpt][2] = fdotc * iptr->constraint[2];
<         break;
<     case 1:                    /* In plane, 2-D restriction (typical). */
<         iptr->force[fpt][0] -= fdotc * iptr->constraint[0];
<         iptr->force[fpt][1] -= fdotc * iptr->constraint[1];
<         iptr->force[fpt][2] -= fdotc * iptr->constraint[2];
<         break;
<     case 0:                    /* Disable constraint */
<         break;
<     }
---
> 	switch (ct.constrainforces)
> 	{
> 		case 2:                    /* NEB tangent to adjacent images */
> 			{
> 				int ion;
> 				ION *iptr;
> 				REAL Mag_T = 0.0;
> 				REAL Mag_L = 0.0;
> 				REAL Mag_R = 0.0;
> 				REAL FdotT = 0.0;
> 				REAL Tau[3*ct.num_ions];
> 				REAL Img_L[3*ct.num_ions];
> 				REAL Img_R[3*ct.num_ions];
> 
> 				for (ion=0; ion < ct.num_ions; ion++)
> 				{
> 					iptr = &ct.ions[ion];
> 
> 					/*Calculate displacement vectors from self to left and right image coords */
> 					Img_L[3*ion+X] = iptr->crds[X] - iptr->constraint.setA_coord[X];
> 					Img_L[3*ion+Y] = iptr->crds[Y] - iptr->constraint.setA_coord[Y];
> 					Img_L[3*ion+Z] = iptr->crds[Z] - iptr->constraint.setA_coord[Z];
> 
> 					Img_R[3*ion+X] = iptr->constraint.setB_coord[X] - iptr->crds[X];
> 					Img_R[3*ion+Y] = iptr->constraint.setB_coord[Y] - iptr->crds[Y];
> 					Img_R[3*ion+Z] = iptr->constraint.setB_coord[Z] - iptr->crds[Z];
> 
> 					/*Calculate displacement vector between left and right image coords */
> 					Tau[3*ion+X] = Img_L[3*ion+X] + Img_R[3*ion+X];
> 					Tau[3*ion+Y] = Img_L[3*ion+Y] + Img_R[3*ion+Y];
> 					Tau[3*ion+Z] = Img_L[3*ion+Z] + Img_R[3*ion+Z];
> 
> 					/*Calculate vector magnitudes (squared) */
> 					Mag_L += Img_L[3*ion+X]*Img_L[3*ion+X]
> 						+ Img_L[3*ion+Y]*Img_L[3*ion+Y]
> 						+ Img_L[3*ion+Z]*Img_L[3*ion+Z];
> 
> 					Mag_R += Img_R[3*ion+X]*Img_R[3*ion+X]
> 						+ Img_R[3*ion+Y]*Img_R[3*ion+Y]
> 						+ Img_R[3*ion+Z]*Img_R[3*ion+Z];
> 
> 					Mag_T += Tau[3*ion+X]*Tau[3*ion+X]
> 						+ Tau[3*ion+Y]*Tau[3*ion+Y]
> 						+ Tau[3*ion+Z]*Tau[3*ion+Z];
> 				}
> 				/*Calculate vector magnitudes */
> 				Mag_L = sqrt(Mag_L);
> 				Mag_R = sqrt(Mag_R);
> 
> 				/* Normalize tangent vector Tau */
> 				if (Mag_T != 0.0)
> 				{
> 					Mag_T = sqrt(Mag_T);
> 					for (ion=0; ion < ct.num_ions; ion++)
> 					{
> 						Tau[3*ion+X] /= Mag_T;
> 						Tau[3*ion+Y] /= Mag_T;
> 						Tau[3*ion+Z] /= Mag_T;
> 					}
> 				}
> 
> 				/* Find the amount of force along the Tau vector */
> 				for (ion=0; ion < ct.num_ions; ion++)
> 				{
> 					FdotT += iptr->force[ct.fpt[0]][X] * Tau[3*ion+X]
> 						+ iptr->force[ct.fpt[0]][Y] * Tau[3*ion+Y]
> 						+ iptr->force[ct.fpt[0]][Z] * Tau[3*ion+Z];
> 				}
> 
> 				/* Calculate the necessary restoring force to keep images from instersecting */
> 				Mag_T = ct.neb_spring_constant*(Mag_R - Mag_L);
> 
> 				/* Remove physical force along Tau, replace it with the restoring force */
> 				for (ion=0; ion < ct.num_ions; ion++)
> 				{
> 					iptr->force[ct.fpt[0]][X] += (Mag_T - FdotT) * Tau[3*ion+X];
> 					iptr->force[ct.fpt[0]][Y] += (Mag_T - FdotT) * Tau[3*ion+Y];
> 					iptr->force[ct.fpt[0]][Z] += (Mag_T - FdotT) * Tau[3*ion+Z];
> 				}
> 			}
> 			break;
> 		case 1:                    /* In plane, 2-D restriction (typical). */
> 			{
> 				int ion;
> 				REAL FdotC;
> 				ION *iptr;
> 				for (ion=0; ion < ct.num_ions; ion++)
> 				{
> 					iptr = &ct.ions[ion];
> 
> 					FdotC = iptr->force[ct.fpt[0]][X] * iptr->constraint.setA_coord[X]
> 						+ iptr->force[ct.fpt[0]][Y] * iptr->constraint.setA_coord[Y]
> 						+ iptr->force[ct.fpt[0]][Z] * iptr->constraint.setA_coord[Z];
> 
> 					iptr->force[ct.fpt[0]][X] -= FdotC * iptr->constraint.setA_coord[X];
> 					iptr->force[ct.fpt[0]][Y] -= FdotC * iptr->constraint.setA_coord[Y];
> 					iptr->force[ct.fpt[0]][Z] -= FdotC * iptr->constraint.setA_coord[Z];
> 				}
> 			}
> 			break;
> 		case 0:                    /* Constraint disabled, should not get here */
> 			break;
> 	}
> 
> 	return;
58a147,344
> 
> #if 0	
> 
> 	switch (iptr->constraint.setA_type)
> 	{
> 		case 4:    /* NEB (simple) tangent to adjacent images */
> 			{   
> 				REAL MagT, MagL, MagR, FdotT, Tau[3], PosL[3], PosR[3];
> 
> 				PosL[0] = iptr->crds[0] - iptr->constraint.setA_coord[0];
> 				PosL[1] = iptr->crds[1] - iptr->constraint.setA_coord[1];
> 				PosL[2] = iptr->crds[2] - iptr->constraint.setA_coord[2];
> 
> 				PosR[0] = iptr->constraint.setB_coord[0] - iptr->crds[0];
> 				PosR[1] = iptr->constraint.setB_coord[1] - iptr->crds[1];
> 				PosR[2] = iptr->constraint.setB_coord[2] - iptr->crds[2];
> 
> 				MagL = sqrt(PosL[0]*PosL[0] + PosL[1]*PosL[1] + PosL[2]*PosL[2]);
> 				MagR = sqrt(PosR[0]*PosR[0] + PosR[1]*PosR[1] + PosR[2]*PosR[2]);
> 
> 				Tau[0] = PosL[0] + PosR[0];
> 				Tau[1] = PosL[1] + PosR[1];
> 				Tau[2] = PosL[2] + PosR[2];
> 
> 				MagT = sqrt(Tau[0]*Tau[0] + Tau[1]*Tau[1] + Tau[2]*Tau[2]);
> 
> 				if (MagT != 0.0)
> 				{
> 					Tau[0] /= MagT;
> 					Tau[1] /= MagT;
> 					Tau[2] /= MagT;
> 				}
> 
> 				FdotT = iptr->force[fpt][0] * Tau[0]
> 					+ iptr->force[fpt][1] * Tau[1]
> 					+ iptr->force[fpt][2] * Tau[2];
> 
> 				MagT = ct.neb_spring_constant*(MagL - MagR);
> 
> 				iptr->force[fpt][0] += (MagT - FdotT) * Tau[0];
> 				iptr->force[fpt][1] += (MagT - FdotT) * Tau[1];
> 				iptr->force[fpt][2] += (MagT - FdotT) * Tau[2];
> 
> 			}
> 			break;
> 		case 3:    /* NEB (enhanced) tangent to adjacent images */
> 			{   
> 				REAL MagT, MagL, MagR, FdotT, Tau[3], PosL[3], PosR[3];
> 
> 				PosL[0] = iptr->crds[0] - iptr->constraint.setA_coord[0];
> 				PosL[1] = iptr->crds[1] - iptr->constraint.setA_coord[1];
> 				PosL[2] = iptr->crds[2] - iptr->constraint.setA_coord[2];
> 
> 				PosR[0] = iptr->constraint.setB_coord[0] - iptr->crds[0];
> 				PosR[1] = iptr->constraint.setB_coord[1] - iptr->crds[1];
> 				PosR[2] = iptr->constraint.setB_coord[2] - iptr->crds[2];
> 
> 				MagL = sqrt(PosL[0]*PosL[0] + PosL[1]*PosL[1] + PosL[2]*PosL[2]);
> 				MagR = sqrt(PosR[0]*PosR[0] + PosR[1]*PosR[1] + PosR[2]*PosR[2]);
> 
> 				if (MagL == 0.0) MagL = 1.0;
> 				if (MagR == 0.0) MagR = 1.0;
> 
> 				Tau[0] = PosL[0]/MagL + PosR[0]/MagR;
> 				Tau[1] = PosL[1]/MagL + PosR[1]/MagR;
> 				Tau[2] = PosL[2]/MagL + PosR[2]/MagR;
> 
> 				MagT = sqrt(Tau[0]*Tau[0] + Tau[1]*Tau[1] + Tau[2]*Tau[2]);
> 
> 				if (MagT != 0.0)
> 				{
> 					Tau[0] /= MagT;
> 					Tau[1] /= MagT;
> 					Tau[2] /= MagT;
> 				}
> 
> 				FdotT = iptr->force[fpt][0] * Tau[0]
> 					+ iptr->force[fpt][1] * Tau[1]
> 					+ iptr->force[fpt][2] * Tau[2];
> 
> 				MagT = ct.neb_spring_constant*(MagL - MagR);
> 				printf("\n\tNat force            is :%f\t%f\t%f", iptr->force[fpt][0], iptr->force[fpt][1], iptr->force[fpt][2]);
> 				printf("\n\tNEB force correction is :%f\t%f\t%f", (MagT - FdotT) * Tau[0], (MagT - FdotT) * Tau[1], (MagT - FdotT) * Tau[2]);
> 
> 				iptr->force[fpt][0] += (MagT - FdotT) * Tau[0];
> 				iptr->force[fpt][1] += (MagT - FdotT) * Tau[1];
> 				iptr->force[fpt][2] += (MagT - FdotT) * Tau[2];
> 
> 			}
> 			break;
> 
> 		case 2:                    /* NEB tangent to adjacent images */
> 			{
> 				REAL Mag, MagL, MagR, FdotT;
> 				REAL Tau[3], TauL[3], TauR[3];
> 				REAL Left_E = iptr->constraint.setA_weight;
> 				REAL This_E = ct.TOTAL;
> 				REAL Right_E = iptr->constraint.setB_weight;
> 
> 
> 				/*Calculate displacement vectors to left and right image coords */
> 				TauL[0] = iptr->crds[0] - iptr->constraint.setA_coord[0];
> 				TauL[1] = iptr->crds[1] - iptr->constraint.setA_coord[1];
> 				TauL[2] = iptr->crds[2] - iptr->constraint.setA_coord[2];
> 
> 				TauR[0] = iptr->constraint.setB_coord[0] - iptr->crds[0];
> 				TauR[1] = iptr->constraint.setB_coord[1] - iptr->crds[1];
> 				TauR[2] = iptr->constraint.setB_coord[2] - iptr->crds[2];
> 
> 				/*Calculate vector magnitudes to left and right image coords */
> 				MagL = sqrt(TauL[0]*TauL[0] + TauL[1]*TauL[1] + TauL[2]*TauL[2]);
> 				MagR = sqrt(TauR[0]*TauR[0] + TauR[1]*TauR[1] + TauR[2]*TauR[2]);
> 
> 				/* Calculate energy weighted tangent vector */
> 				/* Is this image an extrema ? */
> 				if ( (This_E > Left_E && This_E > Right_E)||(This_E < Left_E && This_E < Right_E) )	
> 				{
> 					REAL dEmax = max( fabs(This_E - Left_E), fabs(This_E - Right_E) );
> 					REAL dEmin = min( fabs(This_E - Left_E), fabs(This_E - Right_E) );
> 
> 					if ( Left_E > Right_E )
> 					{
> 						Tau[0] = dEmax*TauL[0] + dEmin*TauR[0];
> 						Tau[1] = dEmax*TauL[1] + dEmin*TauR[1];
> 						Tau[2] = dEmax*TauL[2] + dEmin*TauR[2];
> 					}
> 					else
> 					{
> 						Tau[0] = dEmax*TauR[0] + dEmin*TauL[0];
> 						Tau[1] = dEmax*TauR[1] + dEmin*TauL[1];
> 						Tau[2] = dEmax*TauR[2] + dEmin*TauL[2];
> 					}
> 				}
> 				else /* Image is in a monotonic region */
> 				{
> 					if ( Left_E > Right_E )
> 					{
> 						Tau[0] = TauL[0];
> 						Tau[1] = TauL[1];
> 						Tau[2] = TauL[2];
> 					}
> 					else
> 					{
> 						Tau[0] = TauR[0];
> 						Tau[1] = TauR[1];
> 						Tau[2] = TauR[2];
> 					}
> 				}
> 
> 				/* Normalize Tau */
> 				Mag = sqrt(Tau[0]*Tau[0] + Tau[1]*Tau[1] + Tau[2]*Tau[2]);
> 				if (Mag != 0.0)
> 				{
> 					Tau[0] /= Mag;
> 					Tau[1] /= Mag;
> 					Tau[2] /= Mag;
> 				}
> 
> 				/* Find amount of force along tangent */
> 				FdotT = iptr->force[fpt][0] * Tau[0] +
> 					iptr->force[fpt][1] * Tau[1] +
> 					iptr->force[fpt][2] * Tau[2];
> 
> 				/* Find restoring force necessary to maintain image separation */
> 				Mag = -( MagR - MagL )*(ct.neb_spring_constant);
> 
> 				/* Remove Tau parallel add restoring component of force */
> 				iptr->force[fpt][0] += (Mag - FdotT) * Tau[0];
> 				iptr->force[fpt][1] += (Mag - FdotT) * Tau[1];
> 				iptr->force[fpt][2] += (Mag - FdotT) * Tau[2];
> 
> 				printf("\tNEB force correction is :%f\t%f\t%f\n", (Mag - FdotT) * Tau[0], (Mag - FdotT) * Tau[1], (Mag - FdotT) * Tau[2]);
> 
> 			}
> 			break;
> 		case 1:                    /* In plane, 2-D restriction (typical). */
> 			{
> 				REAL fdotc = iptr->force[fpt][0] * iptr->constraint.setA_coord[0] +
> 					iptr->force[fpt][1] * iptr->constraint.setA_coord[1] +
> 					iptr->force[fpt][2] * iptr->constraint.setA_coord[2];
> 
> 				iptr->force[fpt][0] -= fdotc * iptr->constraint.setA_coord[0];
> 				iptr->force[fpt][1] -= fdotc * iptr->constraint.setA_coord[1];
> 				iptr->force[fpt][2] -= fdotc * iptr->constraint.setA_coord[2];
> 			}
> 			break;
> 		case 0:                    /* Disable constraint */
> 			break;
> 	}
> }
> else
> {
> 	/*constrained to position of ion number -(setA_type) */
> 	;
> }
> }
> #endif
> 
2c2
<  **    $Id: init_wf.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: init_wf.c 1066 2009-08-31 18:41:09Z froze $    **
78,84c78
< 	if (pct.spin_flag)
< 	{
<         	sp->occupation=ct.nel/(ct.num_states+ct.num_states_oppo);
<         	sp->occupation_oppo=ct.nel/(ct.num_states+ct.num_states_oppo);
< 	}
< 	else
<         	sp->occupation = ct.nel / ct.num_states;
---
>         sp->occupation = ct.nel / ct.num_states;
98a93
> 
119,128d113
<     	if (ct.occ_flag && (ct.runflag == 0))
<     	{
< 		if (pct.spin_flag)
< 		{
<         		sp->occupation=ct.nel/(ct.num_states+ct.num_states_oppo);
<         		sp->occupation_oppo=ct.nel/(ct.num_states+ct.num_states_oppo);
< 		}
< 		else
<         		sp->occupation = ct.nel / ct.num_states;
<     	}
129a115,118
>         if (ct.occ_flag && (ct.runflag == 0))
>         {
>             sp->occupation = ct.nel / ct.num_states;
>         }
2c2
<  **    $Id: print_density_z_direction.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: print_density_z_direction.c 1066 2009-08-31 18:41:09Z froze $    **
57c57
<        MPI_Barrier(pct.grid_comm); */
---
>        MPI_Barrier(pct.thisgrp_comm); */
97c97
<             MPI_Send (temp_buff, pz0_grid, MPI_DOUBLE, 0, 100, pct.grid_comm);
---
>             MPI_Send (temp_buff, pz0_grid, MPI_DOUBLE, 0, 100, pct.thisgrp_comm);
105c105
<             MPI_Recv (temp_buff, pz0_grid, MPI_DOUBLE, MPI_ANY_SOURCE, 100, pct.grid_comm,
---
>             MPI_Recv (temp_buff, pz0_grid, MPI_DOUBLE, MPI_ANY_SOURCE, 100, pct.thisgrp_comm,
116c116
<         MPI_Barrier (pct.grid_comm);
---
>         MPI_Barrier (pct.thisgrp_comm);
2c2
<  **    $Id: rft1.c 1150 2010-10-08 17:36:21Z froze $    **
---
>  **    $Id: rft1.c 1161 2010-10-26 23:18:51Z froze $    **
2c2
<  **    $Id: get_vxc.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: get_vxc.c 1066 2009-08-31 18:41:09Z froze $    **
57d56
<     {
59d57
<     }
62d59
<     
67,71c64,65
<         /* xclda_pz81 (nrho, vxc_f); */
< 
< 	/* incoporate both the Perdew Zunger 1981 and Ortiz Ballone 1994, default is PZ 1981 */
<         xclda (nrho, vxc_f, exc);
< 	break;
---
>         xclda_pz81 (nrho, vxc_f);
>         break;
79c73
<         
---
> 
91c85
< 	break;
---
>         break;
2c2
<  **    $Id: scf.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: scf.c 1192 2011-01-20 08:37:16Z miro $    **
52c52
<           REAL * rho,  REAL * rhocore, REAL * rhoc, int *CONVERGENCE)
---
>           REAL * rho, REAL * rhocore, REAL * rhoc, int *CONVERGENCE)
55c55
<     int kpt, st1, idx, ik, st, sttemp;
---
>     int kpt, st1, idx, ik;
57c57
<     REAL *vtot, *vtot_psi ;
---
>     REAL *vtot, *vtot_psi, *new_rho;
60d59
<     MPI_Status status;    
62d60
<     
65a64
>     my_malloc (new_rho, FP0_BASIS, REAL);
69,70d67
< 
< 
76,77c73
<     time1 = my_crtc (); 
<     
---
>     time1 = my_crtc ();
81a78
> 
97d93
< 	dprintf("grid %d: rho %.4e and rhocompen %.4e", idx, rho[idx], rhoc[idx]);
107c103
<     if (pct.imgpe == 0 && !firststep)
---
>     if (pct.thispe == 0 && !firststep)
140a137,139
> 
> 
> 
158d156
<     
160,163c158,160
<     if (!firststep)	
<     {
<     
<     	/* Take care of occupation filling */
---
> 
>     /* Take care of occupation filling */
>     if (!firststep)
165c162
<     }	
---
> 
169c166
<     if (pct.thisimg == 0 && ct.occ_flag == 1 && !firststep)
---
>     if (pct.thispe == 0 && ct.occ_flag == 1 && !firststep)
181c178
<     get_rho (states, rho, rhocore);
---
>     get_new_rho (states, new_rho);
182a180,181
>     /*Takes care of mixing and checks whether the charge density is negative*/
>     mix_rho(new_rho, rho, rhocore, FP0_BASIS, FPX0_GRID, FPY0_GRID, FPZ0_GRID);
192d190
<  
199a198
>     my_free (new_rho);
2c2
<  **    $Id: subdiag_gamma.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: subdiag_gamma.c 1183 2011-01-14 11:03:31Z miro $    **
51d50
< #include "my_scalapack.h"
69,71d67
< #if PULAY
< REAL *global_matrix=NULL;
< #endif
95c91,92
<     int idx, st1, num_states;
---
>     int idx, st1;
> 	int num_states;
104d100
< #if !PULAY
106d101
< #endif
113,114c108
<     int ictxt;
<     int desca[DLEN], dist_length, dist_stop, pbasis;
---
> 	int dist_length, dist_stop, pbasis;
137,143d130
< #if PULAY
<     if (global_matrix == NULL) my_calloc (global_matrix, stop, REAL);
<     else {
< 	for (idx = 0; idx < stop; idx++)
< 	    global_matrix[idx] = 0.0;
<     }
< #else
145d131
< #endif
174,183d159
<     /*Initialize ScaLapack, get context */
<     sl_init (&ictxt, num_states);
< 
< 
<     /*Set desca, variable used in ScaLapack functions */
<     set_desca (desca, &ictxt, &num_states);
< 
< 
< 
< 
189,190c165,166
<             NUMROC (&num_states, &desca[4], &pct.scalapack_myrow, &izero,
<                     &pct.scalapack_nprow) * NUMROC (&num_states, &desca[4], &pct.scalapack_mycol,
---
>             NUMROC (&num_states, &pct.desca[4], &pct.scalapack_myrow, &izero,
>                     &pct.scalapack_nprow) * NUMROC (&num_states, &pct.desca[4], &pct.scalapack_mycol,
256c232
<             distribute_mat (desca, global_matrix, distAij, &num_states);
---
>             distribute_mat (pct.desca, global_matrix, distAij, &num_states);
294c270
<             distribute_mat (desca, global_matrix, distSij, &num_states);
---
>             distribute_mat (pct.desca, global_matrix, distSij, &num_states);
331c307
<             distribute_mat (desca, global_matrix, distBij, &num_states);
---
>             distribute_mat (pct.desca, global_matrix, distBij, &num_states);
361c337
<         distribute_mat (desca, global_matrix, distCij, &num_states);
---
>         distribute_mat (pct.desca, global_matrix, distCij, &num_states);
387c363
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
397,398c373,374
<                 NUMROC (&desca[2], &desca[4], &pct.scalapack_myrow, &desca[6],
<                         &pct.scalapack_nprow) + desca[4];
---
>                 NUMROC (&pct.desca[2], &pct.desca[4], &pct.scalapack_myrow, &pct.desca[6],
>                         &pct.scalapack_nprow) + pct.desca[4];
403,404c379,380
<             PDGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PDGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
406,407c382,383
<             PZGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PZGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
422c398
<         print_dist_matrix (distCij, num_states, desca);
---
>         print_dist_matrix (distCij, num_states, pct.desca);
435,436c411,412
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
439,440c415,416
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
446c422
<             print_dist_matrix (distBij, num_states, desca);
---
>             print_dist_matrix (distBij, num_states, pct.desca);
453,454c429,430
<                     distSij, &ione, &ione, desca, distBij, &ione, &ione, desca, beta, distCij,
<                     &ione, &ione, desca);
---
>                     distSij, &ione, &ione, pct.desca, distBij, &ione, &ione, pct.desca, beta, distCij,
>                     &ione, &ione, pct.desca);
457,458c433,434
<                     distSij, &ione, &ione, desca, distBij, &ione, &ione, desca, beta, distCij,
<                     &ione, &ione, desca);
---
>                     distSij, &ione, &ione, pct.desca, distBij, &ione, &ione, pct.desca, beta, distCij,
>                     &ione, &ione, pct.desca);
469c445
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
496,498c472,474
<             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, desca,
<                      distSij, &ione, &ione, desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
<                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, desca, &lwork_tmp, &lwork,
---
>             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, pct.desca,
>                      distSij, &ione, &ione, pct.desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
>                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, pct.desca, &lwork_tmp, &lwork,
519,521c495,497
<             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, desca,
<                      distSij, &ione, &ione, desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
<                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, desca, work2, &lwork, iwork,
---
>             PDSYGVX (&ione, jobz, range, uplo, &num_states, distBij, &ione, &ione, pct.desca,
>                      distSij, &ione, &ione, pct.desca, &vx, &vx, &ione, &ione, &tol, &eigs_found,
>                      &eigvs_found, eigs, &orfac, distAij, &ione, &ione, pct.desca, work2, &lwork, iwork,
550c526
<         matgather (distAij, desca, global_matrix, num_states);
---
>         matgather (distAij, pct.desca, global_matrix, num_states);
562,564d537
<         /*Exit Scalapack */
<         sl_exit (ictxt);
< 
594c567
<         MPI_Bcast (eigs, num_states, MPI_DOUBLE, 0, pct.grid_comm);
---
>         MPI_Bcast (eigs, num_states, MPI_DOUBLE, 0, pct.thisgrp_comm);
630d602
< #if !PULAY
632d603
< #endif
2c2
<  **    $Id: write_header.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: write_header.c 1161 2010-10-26 23:18:51Z froze $    **
231,242c231
< 
<     if (pct.spin_flag)
<     {
<     	printf ("    This is a spin polarized calculation \n");
<     	printf ("    Number of spin up states   = %d\n", ct.num_states);
<     	printf ("    Number of spin down states   = %d\n", ct.num_states_oppo);
<     }
<     else
<     {
<     	printf ("    This is NOT a spin polarized calculation \n");
<     	printf ("    Number of states   = %d\n", ct.num_states);
<     }	
---
>     printf ("    Number of states   = %d\n", ct.num_states);
355,359c344,348
<             printf ("       % 10f % 10f % 10f %d\n",
< 					ct.ions[idx].constraint[0],
< 					ct.ions[idx].constraint[1],
< 					ct.ions[idx].constraint[2],
<                     ct.ions[idx].constraint_type);
---
>             printf ("       % 10f % 10f % 10f % 10f\n",
> 					ct.ions[idx].constraint.setA_coord[0],
> 					ct.ions[idx].constraint.setA_coord[1],
> 					ct.ions[idx].constraint.setA_coord[2],
>                     ct.ions[idx].constraint.setA_weight);
404c393
<     if ((pct.imgpe == 0) && (verify ("pdb_atoms", NULL)))
---
>     if ((pct.thispe == 0) && (verify ("pdb_atoms", NULL)))
2c2
<  **    $Id: init_pe.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: init_pe.c 1161 2010-10-26 23:18:51Z froze $    **
41,43c41,42
<     int image, image_grp_map[pct.images], grid_grp_map[pct.grids], range[1][3];
<     MPI_Group group, world_grp, image_grp, img_masters;
< 
---
>     int instance, mastergrp[pct.instances], range[1][3];
>     MPI_Group group, grp_world, grp_master;
46d44
<     MPI_Comm_rank (MPI_COMM_WORLD, &pct.thispe);
49,51c47,48
<     /* Every image gets an equal number of PEs. */
<     image = npes / pct.images;
<     if (image * pct.images != npes)
---
>     /* Check for sufficient processors for (multi-instance) run */
>     if (NPES * pct.instances != npes)
53,62c50,51
<             ("Total MPI processes must be a multiple of the number of images in this run.");
<     pct.thisimg = pct.thispe / image;
< 
<     /* Infer the number of cpu grids in each image. */
<     pct.grids = image / NPES;
<     if (NPES * pct.grids != image)
<         error_handler ("MPI processes per image must be a multiple of NPES (PE_X*PE_Y*PE_Z).");
< 
< 
<     /* setup pct.img_comm to include all pe's in this image */
---
>             ("RMG compiled for %d PEs and running %d instances, but allocated %d PEs != PEs*instances !!\n",
>              NPES, pct.instances, npes);
63a53
>     /* setup pct.thisgrp_comm to include all pe's in this instance */
65c55
<     MPI_Comm_group (MPI_COMM_WORLD, &world_grp);
---
>     MPI_Comm_group (MPI_COMM_WORLD, &grp_world);
67,69c57,59
<     /* determine range of pe ranks in this image */
<     range[0][0] = pct.thisimg * pct.grids * NPES;
<     range[0][1] = (pct.thisimg + 1) * pct.grids * NPES - 1;
---
>     /* determine range of pe ranks in this instance */
>     range[0][0] = pct.thisgrp * NPES;
>     range[0][1] = (pct.thisgrp + 1) * NPES - 1;
72,74c62,64
<     /* define this images group and put its comm in pct */
<     MPI_Group_range_incl (world_grp, 1, range, &group);
<     MPI_Comm_create (MPI_COMM_WORLD, group, &pct.img_comm);
---
>     /* define this instances group and make its comm global */
>     MPI_Group_range_incl (grp_world, 1, range, &group);
>     MPI_Comm_create (MPI_COMM_WORLD, group, &pct.thisgrp_comm);
76c66,70
<     /* setup pct.rmg_comm to include all image group_rank 0 pe's */
---
>     /* reset thispe rank value to local instance value */
>     MPI_Group_rank (group, &pct.thispe);
> 
> 
>     /* setup pct.master_comm to include all group_rank 0 pe's */
79,135c73,74
<     for (image = 0; image < pct.images; image++)
<         image_grp_map[image] = image * NPES * pct.grids;
< 
<     /* define master group and make its comm global */
<     MPI_Group_incl (world_grp, pct.images, image_grp_map, &img_masters);
<     MPI_Comm_create (MPI_COMM_WORLD, img_masters, &pct.rmg_comm);
< 
<     /* set thispe rank value to its image rank */
<     MPI_Comm_rank (pct.img_comm, &pct.imgpe);
< 
<     /* Read in our control information, depends on pct.img_comm for dissemination */
<     read_control ();
< 
< 
<     /* this will need to be extnded if we want to parallelize over k_points */
<     if (pct.grids == 1)
<     {
<         if (pct.spin_flag)
<             error_handler
<                 ("Spin calculations require 2 grids, please rerun with twice as many PEs.");
<         MPI_Comm_dup (pct.img_comm, &pct.grid_comm);
<     }
<     else if (pct.grids == 2)
<     {
<         if (!pct.spin_flag)
<             error_handler
<                 ("2 grids allocated but spin disabled, please rerun with half as many PEs or enable spin.");
<         int ndims = 2;
<         int dims[] = { NPES, 2 };
<         int periods[] = { 0, 0 };
<         int reorder = 1;
<         int remains[] = { 1, 0 };
< 
<         MPI_Cart_create (pct.img_comm, ndims, dims, periods, reorder, &pct.grid_topo_comm);
<         MPI_Cart_sub (pct.grid_topo_comm, remains, &pct.grid_comm);
< 
<         remains[0] = 0;
<         remains[1] = 1;
<         MPI_Cart_sub (pct.grid_topo_comm, remains, &pct.spin_comm);
<     	/* set thisspin rank value to local spin rank value */
<     	MPI_Comm_rank (pct.spin_comm, &pct.thisspin);
< 
< 	/* for debug usage*/
< 	/* MPI_Comm_rank(pct.grid_comm, &pct.thisgrid); */
< 	
< 	/*printf("My spin rank is %d and my image rank is %d\n", pct.thisspin, pct.imgpe);*/
< 	
< 
<     }
<     else
<     {
<         error_handler ("Other than one or two grids per image not implimented.");
<     }
< 
<     /* set thispe rank value to local grid rank value */
<     MPI_Comm_rank (pct.grid_comm, &pct.thispe);
<     /*printf("My grid rank is %d and my image rank is %d\n", pct.thispe, pct.imgpe);*/
---
> 	for (instance = 0; instance < pct.instances; instance++)
> 		mastergrp[instance] = instance * NPES;
136a76,78
> 	/* define master group and make its comm global */
> 	MPI_Group_incl (grp_world, pct.instances, mastergrp, &grp_master);
> 	MPI_Comm_create (MPI_COMM_WORLD, grp_master, &pct.master_comm);
164c106
<     //dprintf("Finished init_pe, all MPI groups defined.\n");
---
> 	//dprintf("Finished init_pe, all MPI groups defined.\n");
2c2
<  **    $Id: rmg_fastrelax.c 1066 2009-08-31 18:41:09Z froze $    **
---
>  **    $Id: rmg_fastrelax.c 1186 2011-01-15 06:09:45Z miro $    **
58,59c58,63
<         /* Get ionic mass */
<         mass = ct.sp[iptr->species].atomic_mass * mu_me;
---
>         /* Use either actual ionic mass or equal mass for all atoms*/
> 	if (ct.fastrelax_mass == 0)
> 	    mass = ct.sp[iptr->species].atomic_mass * mu_me;
> 	else
> 	    mass =  12.0 * mu_me;
> 	
71,73d74
<         if (dotfv <= 0.1e-12)
<             dotfv /= THREE;
< 
135,136d135
< 
< 
2c2
<  **    $Id: subdiag_nongamma.c 1134 2010-08-18 08:40:51Z miro $    **
---
>  **    $Id: subdiag_nongamma.c 1163 2010-11-03 19:43:40Z froze $    **
80c80,81
<     int idx, st1, num_states;
---
>     int idx, st1;
> 	int num_states = pct.size;
92,93c93
<     int ictxt;
<     int desca[DLEN], dist_length, dist_stop;
---
>     int dist_length, dist_stop;
183,188d182
<     /*Initialize ScaLapack, get context */
<     sl_init (&ictxt, num_states);
< 
< 
<     /*Set desca, variable used in ScaLapack functions */
<     set_desca (desca, &ictxt, &num_states);
198,199c192,193
<             NUMROC (&num_states, &desca[4], &pct.scalapack_myrow, &izero,
<                     &pct.scalapack_nprow) * NUMROC (&num_states, &desca[4], &pct.scalapack_mycol,
---
>             NUMROC (&num_states, &pct.desca[4], &pct.scalapack_myrow, &izero,
>                     &pct.scalapack_nprow) * NUMROC (&num_states, &pct.desca[4], &pct.scalapack_mycol,
225,227c219,221
<         distribute_mat (desca, Aij, distAij, &num_states);
<         distribute_mat (desca, Bij, distBij, &num_states);
<         distribute_mat (desca, Cij, distCij, &num_states);
---
>         distribute_mat (pct.desca, Aij, distAij, &num_states);
>         distribute_mat (pct.desca, Bij, distBij, &num_states);
>         distribute_mat (pct.desca, Cij, distCij, &num_states);
236c230
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
244c238
<         print_dist_matrix (distBij, num_states, desca);
---
>         print_dist_matrix (distBij, num_states, pct.desca);
248c242
<         print_dist_matrix (distAij, num_states, desca);
---
>         print_dist_matrix (distAij, num_states, pct.desca);
257,258c251,252
<                 NUMROC (&desca[2], &desca[4], &pct.scalapack_myrow, &desca[6],
<                         &pct.scalapack_nprow) + desca[4];
---
>                 NUMROC (&pct.desca[2], &pct.desca[4], &pct.scalapack_myrow, &pct.desca[6],
>                         &pct.scalapack_nprow) + pct.desca[4];
263,264c257,258
<             PDGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PDGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
266,267c260,261
<             PZGESV (&num_states, &num_states, distBij, &ione, &ione, desca, ipiv, distCij, &ione,
<                     &ione, desca, &info);
---
>             PZGESV (&num_states, &num_states, distBij, &ione, &ione, pct.desca, ipiv, distCij, &ione,
>                     &ione, pct.desca, &info);
282c276
<         print_dist_matrix (distCij, num_states, desca);
---
>         print_dist_matrix (distCij, num_states, pct.desca);
295,296c289,290
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
299,300c293,294
<                     distCij, &ione, &ione, desca, distAij, &ione, &ione, desca, beta, distBij,
<                     &ione, &ione, desca);
---
>                     distCij, &ione, &ione, pct.desca, distAij, &ione, &ione, pct.desca, beta, distBij,
>                     &ione, &ione, pct.desca);
306c300
<             print_dist_matrix (distBij, num_states, desca);
---
>             print_dist_matrix (distBij, num_states, pct.desca);
314c308
<         symmetrize_matrix (distBij, distIij, num_states, desca, dist_length);
---
>         symmetrize_matrix (distBij, distIij, num_states, pct.desca, dist_length);
329,330c323,324
<             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, t1, &lwork, &info);
---
>             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, t1, &lwork, &info);
332,333c326,327
<             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, t1, &lwork, t2, &lrwork, &info);
---
>             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, t1, &lwork, t2, &lrwork, &info);
344,345c338,339
<             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, work2, &lwork, &info);
---
>             PDSYEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, work2, &lwork, &info);
350,351c344,345
<             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, desca, work1, distAij, &ione,
<                     &ione, desca, work2, &lwork, work3, &lrwork, &info);
---
>             PCHEEV (jobz, uplo, &num_states, distBij, &ione, &ione, pct.desca, work1, distAij, &ione,
>                     &ione, pct.desca, work2, &lwork, work3, &lrwork, &info);
367c361
<         matgather (distAij, desca, Aij, num_states);
---
>         matgather (distAij, pct.desca, Aij, num_states);
377,379d370
< 
<         /*Exit Scalapack */
<         sl_exit (ictxt);
2c2
<  **    $Id: fastrlx.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: fastrlx.c 1161 2010-10-26 23:18:51Z froze $    **
70c70
<     if ((ct.rmvmovie) && (ct.max_rlx_steps > 1 && pct.imgpe == 0))
---
>     if ((ct.rmvmovie) && (ct.max_rlx_steps > 1 && pct.thispe == 0))
80c80
<     if ((ct.xbsmovie) && (ct.max_rlx_steps > 1 && pct.imgpe == 0))
---
>     if ((ct.xbsmovie) && (ct.max_rlx_steps > 1 && pct.thispe == 0))
94,96d93
< 	/* save data to file for future restart */
< 	if (DONE)
< 		write_data (ct.outfile, vh, rho, vxc, states);
103c100
<         if (pct.imgpe == 0)
---
>         if (pct.thispe == 0)
153c150
< 	if (ct.max_rlx_steps > 0 && pct.thispe == 0)
---
> 	if (ct.max_rlx_steps > 0)
2c2
<  **    $Id: sortpsi.c 1066 2009-08-31 18:41:09Z froze $    **
---
>  **    $Id: sortpsi.c 1210 2011-01-25 18:26:02Z froze $    **
85,88d84
< 
< #if UNICOS_T3E
<                 sswap (&n, sp->psiR, &incx, sp1->psiR, &incx);
< #else
93d88
< #endif
2c2
<  **    $Id: nlforce1.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: nlforce1.c 1066 2009-08-31 18:41:09Z froze $    **
142c142
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
177c177
<         if (pct.imgpe == 0)
---
>         if (pct.thispe == 0)
202c202
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
231c231
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
233c233
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
2c2
<  **    $Id: init_IO.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: init_IO.c 1163 2010-11-03 19:43:40Z froze $    **
22c22
<  *   init_pe.c read_pseudo.c
---
>  *   None
38c38
<     int status, lognum = 0;
---
>     int status, lognum=0;
45a46,53
>     /* Initialize MPI, we need it for error_handler, amongst others */
>     MPI_Init (&argc, &argv);
>     MPI_Comm_rank (MPI_COMM_WORLD, &pct.thispe);
>     pct.thisgrp = pct.thispe / NPES;
> 
>     /* Define a default output stream, gets redefined to log file later */
>     ct.logfile = stdout;
> 
51,52c59,60
<     /* test to see if argument 1 determines a multi-image run, fail gracefully if not */
<     pct.images = 1;
---
>     /* test to see if argument 1 determines a multi-instance run, fail gracefully if not */
>     pct.instances = 1;
59c67
<         pct.images = (int) strtol (quantity, &endptr, 10);
---
>         pct.instances = (int) strtol (quantity, &endptr, 10);
61c69
<         /*Check if this is *just* a number, not some numerical naming convention */
---
>         /*Check if this is *just* a number, not some numerical naming convention*/
63c71
<             pct.images = 1;
---
>             pct.instances = 1;
66c74
<     Dprintf ("RMG will run with %d images", pct.images);
---
>     Dprintf("RMG will run with %d instances", pct.instances);
71c79
<     if (pct.images > 1)
---
>     if (pct.instances > 1)
75c83,84
<                 ("Multi-image input file %s does not end with proper \"rmg\" extension.", argv[1]);
---
>                 ("Multi-instance input file %s does not end with proper \"rmg\" extension.",
>                  argv[1]);
77c86
<         /* logfile name is based on input file and this images group number */
---
>         /* logfile name is based on input file and this instances group number */
81c90
<             snprintf (logname, MAX_PATH, "%s.%d.log", argv[2], pct.thisimg + 1);
---
>             snprintf (logname, MAX_PATH, "%s.%d.log", argv[2], pct.thisgrp + 1);
85c94
<             snprintf (logname, MAX_PATH, "%s.%d.log", basename, pct.thisimg + 1);
---
>             snprintf (logname, MAX_PATH, "%s.%d.log", basename, pct.thisgrp + 1);
89c98
<         snprintf (ct.cfile, MAX_PATH, "../%s.%d.rmg", basename, pct.thisimg + 1);
---
>         snprintf (ct.cfile, MAX_PATH, "../%s.%d.rmg", basename, pct.thisgrp + 1);
91,93c100,102
<         /* every image has it own output/working directory */
<         sprintf (workdir, "image.%d", pct.thisimg + 1);
<         if (pct.imgpe == 0)
---
>         /* every instance has it own output/working directory */
>         sprintf (workdir, "image.%d", pct.thisgrp + 1);
>         if ( pct.thispe == 0 )
95c104
<             if (status = stat (workdir, &buffer) == 0)
---
>             if (status = stat ( workdir, &buffer ) == 0)
97,100c106,107
<                 if (!S_ISDIR (buffer.st_mode))
<                     error_handler
<                         ("Found %s, that is not a directory as required for multi-image run!",
<                          workdir);
---
>                 if ( !S_ISDIR( buffer.st_mode))
>                     error_handler ("Found %s, that is not a directory as required for multi-instance run!", workdir);
120c127
<         /* Not multi-image run, so set output file accordingly */
---
>         /* Not multi-instance run, so set output file accordingly */
132c139
<                 *extension++ = '\0';
---
>                     *extension++ = '\0';
146,149c153,154
<     if (pct.imgpe == 0)
<     {
<         while ((status = stat (logname, &buffer)) != -1)
<         {
---
>     if (pct.thispe == 0 ) {
>         while ((status = stat (logname, &buffer)) != -1) {
152,153c157
<                 error_handler
<                     ("You have over 100 logfiles, you need to think of a better job scenario!\n");
---
>                 error_handler("You have over 100 logfiles, you need to think of a better job scenario!\n");
157c161
<                 if (quantity[1] == 'r')
---
>                 if ( quantity[1] == 'r' )
159c163
<             snprintf (logname, MAX_PATH, "%s.r%02d.log", basename, lognum);
---
>             snprintf (logname, MAX_PATH, "%s.r%02d.log", basename, lognum );
166c170
<     MPI_Comm_size (pct.grid_comm, &status);
---
>     MPI_Comm_size (pct.thisgrp_comm, &status);
168a173,175
> 
>     /* Read in our control information */
>     read_control ();
2c2
<  **    $Id: write_occ.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: write_occ.c 1066 2009-08-31 18:41:09Z froze $    **
65,68d64
<     
<     if (pct.spin_flag)
<     {
< 	printf ("\n\n  STATE OCCUPATIONS for spin up:\n");
70,81c66
<     	for (i = 0; i < ct.num_states; i++)
<         	printf (" %7.2f%s", states[i].occupation, ((i % 10 == 9) ? "\n" : ""));
< 	
< 	printf ("\n\n  STATE OCCUPATIONS for spin down:\n");
< 
<     	for (i = 0; i < ct.num_states_oppo; i++)
<         	printf (" %7.2f%s", states[i].occupation_oppo, ((i % 10 == 9) ? "\n" : ""));
< 	printf ("\n");
<     }  
<     else 
<     {
< 	printf ("\n\n  STATE OCCUPATIONS :\n");
---
>     printf ("\n\n  STATE OCCUPATIONS:\n");
83,85c68,69
<     	for (i = 0; i < ct.num_states; i++)
<         	printf (" %7.2f%s", states[i].occupation, ((i % 10 == 9) ? "\n" : ""));
< 	printf ("\n");
---
>     for (i = 0; i < ct.num_states; i++)
>         printf (" %7.2f%s", states[i].occupation, ((i % 10 == 9) ? "\n" : ""));
87c71
<     }
---
>     printf ("\n");
2c2
<  **    $Id: xcgga.c 1146 2010-09-29 17:43:50Z btan $    **
---
>  **    $Id: xcgga.c 1161 2010-10-26 23:18:51Z froze $    **
47c47
< #define    SMALL  1.e-10
---
> #define    SMALL  1.e-8
52,56c52,63
<     int ix, iy, iz, idx, iflag;
<     FP0_GRID *gx, *gy, *gz, *vgx, *vgy, *vgz, *agg, *d2rho;
<     REAL d, grad, vxc1, vxc2[FP0_BASIS], enxc;
<     REAL kf, pisq3, ex, vx, ec, vc, rs;
< 
---
> #if 1
>     int ix, iy, iz, idx;
>     FP0_GRID *gx, *gy, *gz, *agx, *agy, *agz, *agg, *d2rho;
>     REAL d, s, u, v, kf, us, uu, t, vv, ww;
>     REAL pisq3, ex, vx, ec;
>     REAL zet, rs, g, h, sk, gks2;
>     REAL vcup, vcdn;
>     REAL dvcup, dvcdn;
>     REAL ecrs, eczet, alfc;
>     REAL cpot, cen, xen;
>     REAL dhalf, d1half[3], d2half, vcm0, fac;
>     int ndim = 3, lgga, lpot;
65,67c72,74
<     my_malloc (vgx, 1, FP0_GRID);
<     my_malloc (vgy, 1, FP0_GRID);
<     my_malloc (vgz, 1, FP0_GRID);
---
>     my_malloc (agx, 1, FP0_GRID);
>     my_malloc (agy, 1, FP0_GRID);
>     my_malloc (agz, 1, FP0_GRID);
93,94c100,108
<     
<     /* The LDA part of exchange correlation potential and energy */
---
> 
> 
> 
>     /* Get its gradient */
>     app_gradf (agg->s2, agx, agy, agz);
> 
> 
> 
>     /* Now get the potential */
97,105c111,182
< 	    d = fabs (rho[idx]);
< 	    if (d < SMALL && ct.scf_steps < 10)
< 	    {
< 		    vxc[idx] = 0.0;
< 		    exc[idx] = 0.0;
< 		    continue;
< 	    }
<             
< 	    kf = pow (pisq3 * d, 0.333333333333333);
---
> 
>         if ((d=rho[idx]) < SMALL && ct.scf_steps < 10)
>         {
>             d = SMALL;
>             fac = exp (50. * (rho[idx] / d - 1.0));
>         }
>         else
>         {
>             fac = 1.0;
>         }
>         //kf = pow (pisq3 * d, 0.333333333333333);
>         kf = cbrt (pisq3 * d);
> 
>         s = agg->s2[idx] / (TWO * kf * d);
>         us = gx->s2[idx] * agx->s2[idx] + gy->s2[idx] * agy->s2[idx] + gz->s2[idx] * agz->s2[idx];
>         /* 
>            us = agg->s2[idx] * d2rho->s2[idx];
>          */
> 
>         u = us / (d * d * EIGHT * kf * kf * kf);
> 
>         v = d2rho->s2[idx] / (FOUR * d * kf * kf);
> 
>         if (mode == GGA_BLYP || mode == GGA_XB_CP)
>         {
> 
>             /* Exchange potential from becke */
>             xbecke (&d, &s, &u, &v, &ex, &vx);
> 
>         }
>         else if (mode == GGA_PBE)
>         {
> 
>             /* exchange potential from Perdew, Burke, Ernzerhof */
>             lpot = 1;
>             lgga = 1;
>             exchpbe (&d, &s, &u, &v, &lpot, &lgga, &ex, &vx);
>         }
>         else if (mode == GGA_XP_CP)
>         {
> 
>             /* Exchange potential from Perdew */
>             exch (&d, &s, &u, &v, &ex, &vx);
> 
>         }                       /* end if */
> 
> 
>         if (mode == GGA_BLYP)
>         {
>             if ((d = rho[idx]) < 1.e-15)
>             {
>                 cen = 0.0;
>                 cpot = 0.0;
>             }
>             else
>             {
>                 if (d < SMALL)
>                     d = SMALL;
>                 dhalf = d / 2.0;
>                 d1half[0] = gx->s2[idx] / 2.0;
>                 d1half[1] = gy->s2[idx] / 2.0;
>                 d1half[2] = gz->s2[idx] / 2.0;
>                 d2half = d2rho->s2[idx] / 2.0;
>                 corlyp (&dhalf, &dhalf, d1half, d1half, &d2half, &d2half, &cen, &cpot, &vcm0,
>                         &ndim);
>             }
>             vxc[idx] = fac * (cpot + vx);
>             exc[idx] = fac * (cen + ex);
>         }
>         else if (mode == GGA_PBE)
>         {
>             zet = ZERO;         /* Spin up = spin down */
107,135c184,211
< 	    
< 	    /* to determine which set of monte carlo parameter to use for certain xc functionals */
< 	    iflag = 0;           
< 	   
< 	    if (mode == GGA_PBE)
< 	    {
< 	            /* exchange potential and energy */
<                     slater (rs, &ex, &vx); 
< 	
< 	            /* correlation potential and energy */
< 	            pw (rs, iflag , &ec, &vc);
< 	    }
< 	    else if (mode == GGA_XB_CP)
< 	    {
<                     slater (rs, &ex, &vx); 
< 	            
< 		    pz (rs, iflag , &ec, &vc);
< 	    }
< 	    else if (mode == GGA_XP_CP)
< 	    {
<                     slater (rs, &ex, &vx); 
< 	
< 	            pw (rs, iflag , &ec, &vc);
< 	    }
< 	    else if (mode == GGA_BLYP)
< 	    {
<                     slater (rs, &ex, &vx); 
< 	
< 	            lyp (rs, &ec, &vc);
---
>             sk = TWO * sqrt (kf / PI);
> 
>             g = ONE;
> 
>             gks2 = TWO * sk * g;
> 
> 
>             t = agg->s2[idx] / (d * gks2);
>             uu = us / (d * d * gks2 * gks2 * gks2);
>             vv = d2rho->s2[idx] / (d * gks2 * gks2);
>             ww = ZERO;          /* Non-spin polarized case */
> 
>             lpot = 1;
>             lgga = 1;
>             corpbe (&rs, &zet, &t, &uu, &vv, &ww, &lgga, &lpot, &ec, &vcup, &vcdn,
>                     &h, &dvcup, &dvcdn);
> 
>             cpot = vcup + dvcup;
>             cen = ec + h;
> 
>             vxc[idx] = cpot + vx;
>             exc[idx] = cen + ex;
>             
> 	    if (d < 1.e-12)
> 	    { 
> 		    vxc[idx] = mu_pz(d);
> 		    exc[idx] = e_pz(d);
> 
137,143d212
< 	    
< 	   
< 	    /* local density approximation contribution to xc potential and energy */
< 	    vxc[idx] = vc + vx;  
<             exc[idx] = ex + ec;
< 	    
<     }                             /* end for */
145c214,220
<     
---
>         }
>         else
>         {
>             /* LSD contribution to correlation */
>             zet = ZERO;         /* Spin up = spin down */
>             rs = crs / kf;
>             corlsd (&rs, &zet, &ec, &vcup, &vcdn, &ecrs, &eczet, &alfc);
147,209d221
<     /* add the gradient correction for exchange correlation potential and energy */
<     for (idx = 0; idx < FP0_BASIS; idx++)
<     {
< 	
< 	d = rho[idx];
< 	grad = agg->s2[idx]; 
< 
<         if (mode == GGA_PBE)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxcpbe (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 
< 		     /* add the gradient correction to xc potential and energy now */
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;    /* first term of gradient correction to potential*/
< 	     }	     
<         }
< 	else if (mode == GGA_XB_CP)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxbcp (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;
< 	     }	     
<         }
< 	else if (mode == GGA_XP_CP)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxcpw91 (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;
< 	     }	     
<         }
< 	else if (mode == GGA_BLYP)
<         {
< 	     if (fabs(d) < (1.e-6) || grad < (1.e-5)  )
< 	     {
< 		     vxc2[idx] = 0;
< 	     }
< 	     else
< 	     {
< 	    	     gcxcblyp (d, grad, &enxc, &vxc1, &vxc2[idx]); 
< 	             exc[idx] += enxc;
<                      vxc[idx] += vxc1;
< 	     }	     
<         }
< 
<     }                           /* end for */ 
210a223
>             sk = TWO * sqrt (kf / PI);
211a225,231
> #if 0
>             /* commented out for speed since we are doing spin-unpolarized calculations */
>             g = pow (1.0 + zet, 0.6666666666666666);
>             g += pow (1.0 - zet, 0.6666666666666666);
>             g = g / TWO;
> #endif
>             g = ONE;
213,214c233
<     /* Get gradient of vxc2 */
<     app_gradf (vxc2, vgx, vgy, vgz);
---
>             gks2 = TWO * sk * g;
217,225c236,245
<      /* add the second term gradient correction to xc potential */
<     for (idx = 0; idx < FP0_BASIS; idx++)
<     {
< 	     vxc[idx] += ( vgx->s2[idx] * gx->s2[idx] + 
< 	     		   vgy->s2[idx] * gy->s2[idx] + vgz->s2[idx] * gz->s2[idx] ) ;
< 	     vxc[idx] += vxc2[idx] * d2rho->s2[idx];
<     }
<    
<     
---
>             t = agg->s2[idx] / (d * gks2);
>             uu = us / (d * d * gks2 * gks2 * gks2);
>             vv = d2rho->s2[idx] / (d * gks2 * gks2);
>             ww = ZERO;          /* Non-spin polarized case */
> 
>             corgga (&rs, &zet, &t, &uu, &vv, &ww, &h, &dvcup, &dvcdn, &kf, &sk,
>                     &g, &ec, &ecrs, &eczet);
> 
>             cpot = vcup + dvcup;
>             cen = ec + h;
226a247,248
>             vxc[idx] = cpot + vx;
>             exc[idx] = cen + ex;
228c250,252
<     
---
>         }
> 
>     }                           /* end for */
237,239c261,263
<     my_free (vgz);
<     my_free (vgy);
<     my_free (vgx);
---
>     my_free (agz);
>     my_free (agy);
>     my_free (agx);
242a267
> #endif
2c2
<  **    $Id: init_nuc.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: init_nuc.c 1066 2009-08-31 18:41:09Z froze $    **
124,129c124
<     ct.crho = real_sum_all (ct.crho);  /* sum over pct.grid_comm  */
< 
<     
<     if (pct.imgpe==0)
< 	    printf("\nCompensating charge is %.4e\n", ct.crho);
<     
---
>     ct.crho = real_sum_all (ct.crho);
2c2
<  **    $Id: write_data.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: write_data.c 1161 2010-10-26 23:18:51Z froze $    **
86c86
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
93c93
<         if (pct.imgpe == 0)
---
>         if (pct.thispe == 0)
109a110,111
>         if (pct.thispe == 0)
>             printf ("write_data: Wavefile %s opened...\n", name);
255c257
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
2c2
<  **    $Id: lforce.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: lforce.c 1066 2009-08-31 18:41:09Z froze $    **
161,165c161,166
<         } 
< 	/* end for */
<        	iptr->force[ct.fpt[0]][0] -= ct.vel_f * real_sum_all (fx);
<        	iptr->force[ct.fpt[0]][1] -= ct.vel_f * real_sum_all (fy);
<        	iptr->force[ct.fpt[0]][2] -= ct.vel_f * real_sum_all (fz);
---
>         }                       /* end for */
> 
>         iptr->force[ct.fpt[0]][0] -= ct.vel_f * real_sum_all (fx);
>         iptr->force[ct.fpt[0]][1] -= ct.vel_f * real_sum_all (fy);
>         iptr->force[ct.fpt[0]][2] -= ct.vel_f * real_sum_all (fz);
> 
2c2
<  **    $Id: trade_images.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: trade_images.c 1066 2009-08-31 18:41:09Z froze $    **
93c93
<                   MPI_DOUBLE, nb_ids[NB_D], 1, pct.grid_comm, &mstatus);
---
>                   MPI_DOUBLE, nb_ids[NB_D], 1, pct.thisgrp_comm, &mstatus);
119c119
<                   MPI_DOUBLE, nb_ids[NB_U], 1, pct.grid_comm, &mstatus);
---
>                   MPI_DOUBLE, nb_ids[NB_U], 1, pct.thisgrp_comm, &mstatus);
140c140
<                   newtype, nb_ids[NB_S], 3, pct.grid_comm, &mstatus);
---
>                   newtype, nb_ids[NB_S], 3, pct.thisgrp_comm, &mstatus);
142c142
<                   newtype, nb_ids[NB_N], 4, pct.grid_comm, &mstatus);
---
>                   newtype, nb_ids[NB_N], 4, pct.thisgrp_comm, &mstatus);
154c154
<                   mat, stop, MPI_DOUBLE, nb_ids[NB_W], 5, pct.grid_comm, &mstatus);
---
>                   mat, stop, MPI_DOUBLE, nb_ids[NB_W], 5, pct.thisgrp_comm, &mstatus);
156c156
<                   &mat[xmax + incx], stop, MPI_DOUBLE, nb_ids[NB_E], 6, pct.grid_comm, &mstatus);
---
>                   &mat[xmax + incx], stop, MPI_DOUBLE, nb_ids[NB_E], 6, pct.thisgrp_comm, &mstatus);
2c2
<  **    $Id: output_eigenvalues.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: output_eigenvalues.c 1066 2009-08-31 18:41:09Z froze $    **
72,73c72,74
< 	
< 	if (pct.spin_flag)
---
> 
>         il = 0;
>         for (is = 0; is < ct.num_states; is++)
75,114c76,82
< 		/* Spin up*/
< 		printf("Spin up eigenvalues:\n");
< 		il = 0;
<         	for (is = 0; is < ct.num_states; is++)
<         	{
<             		if (is % 4 == 0)
<                 		printf ("[kpt %3d %3d %3d]", jk, iscf, il++);
< 
<             		printf ("   %9.4f [%5.3f]%s",
<                     		st[is].eig * Ha_eV, st[is].occupation, ((is % 4 == 3) ? "\n" : ""));
<         	}
<         	printf ("\n");
< 
< 		/* Spin down*/
< 		printf("Spin down eigenvalues:\n");
< 		il = 0;
<         	for (is = 0; is < ct.num_states_oppo; is++)
<         	{
<             		if (is % 4 == 0)
<                 		printf ("[kpt %3d %3d %3d]", jk, iscf, il++);
< 
<             		printf ("   %9.4f [%5.3f]%s",
<                     		st[is].eig_oppo * Ha_eV, st[is].occupation_oppo, ((is % 4 == 3) ? "\n" : ""));
<         	}
<         	printf ("\n");
< 
< 	}
< 	else
< 	{
< 		il = 0;
<         	for (is = 0; is < ct.num_states; is++)
<         	{
<             		if (is % 4 == 0)
<                			 printf ("[kpt %3d %3d %3d]", jk, iscf, il++);
< 
<             		printf ("   %9.4f [%5.3f]%s",
<                     		st[is].eig * Ha_eV, st[is].occupation, ((is % 4 == 3) ? "\n" : ""));
<         	}
<         	printf ("\n");
< 	}
---
>             if (is % 4 == 0)
>                 printf ("[kpt %3d %3d %3d]", jk, iscf, il++);
> 
>             printf ("   %9.4f [%5.3f]%s",
>                     st[is].eig * Ha_eV, st[is].occupation, ((is % 4 == 3) ? "\n" : ""));
>         }
>         printf ("\n");
2c2
<  **    $Id: main.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: main.c 1167 2010-11-18 00:43:20Z froze $    **
57,59d56
< 
< /* "VariableName_buff" used to receive and hold the same variable from the oppisite spin*/
< 
61c58
< STATE *states;  
---
> STATE *states;
66c63
< REAL rho[FP0_BASIS], rho_buff[FP0_BASIS];   /* buff used to hold opposite spin density*/
---
> REAL rho[FP0_BASIS];
98d94
< 
135c131
<         run ();
---
>     run ();
150,156d145
<     /* Define a default output stream, gets redefined to a file in init_pe */
<     ct.logfile = stdout;
< 
<     /* Initialize MPI, we need it for error_handler, amongst others */
<     MPI_Init (&argc, &argv);
<     
< 
161d149
< 
163,167c151
<     if (pct.spin_flag)
< 	    states=init_states_spin ();
<     else
<             states = init_states ();
< 
---
>     states = init_states ();
175,180c159
<     
<     if (pct.spin_flag)
<     	init_spin (vh, rho, rho_buff, rhocore, rhoc, states, vnuc, vxc);
<     else 
<     	init (vh, rho, rhocore, rhoc, states, vnuc, vxc);
< 
---
>     init (vh, rho, rhocore, rhoc, states, vnuc, vxc);
182d160
<   
184c162
<     if (pct.imgpe == 0 )
---
>     if (pct.thispe == 0)
198d175
< 
200d176
<     
202,203d177
<     /* Wait until everybody gets here */
<     MPI_Barrier(MPI_COMM_WORLD);
204a179,180
>     /* Wait until everybody gets here */
>     my_barrier ();
218,223c194
< 	if (pct.spin_flag)
< 	{
< 		fastrlx_spin (states, vxc, vh, vnuc, rho, rho_buff, rhocore, rhoc);
< 	}
< 	else
<         	fastrlx (states, vxc, vh, vnuc, rho, rhocore, rhoc);
---
>         fastrlx (states, vxc, vh, vnuc, rho, rhocore, rhoc);
227,232c198
< 	if (pct.spin_flag)
< 	{
< 		fastrlx_spin (states, vxc, vh, vnuc, rho, rho_buff, rhocore, rhoc);
< 	}
< 	else
<         	fastrlx (states, vxc, vh, vnuc, rho, rhocore, rhoc);
---
>         fastrlx (states, vxc, vh, vnuc, rho, rhocore, rhoc);
296c262
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
305a272,276
> 	/*Exit Scalapack */
>     if (pct.scalapack_pe)
>         sl_exit (pct.ictxt);
> 
> 	/*Exit MPI */
2c2
<  **    $Id: real_sum_all.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: real_sum_all.c 1144 2010-09-24 17:48:57Z froze $    **
55c55
<     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_SUM, pct.grid_comm);
---
>     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_SUM, pct.thisgrp_comm);
69,115c69
< 
< 
< REAL real_sum_all_spin (REAL x)
< {
< 
<     REAL inreg;
<     REAL outreg;
< #if MD_TIMERS
<     REAL time0;
< 
<     time0 = my_crtc ();
< #endif
< 	
< 
< 
<     inreg = x; 
<     
<     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
< 
< #if MD_TIMERS
<     rmg_timings (REAL_SUM_ALL_TIME, my_crtc () - time0, 0);
< #endif
< 
< 
<     return outreg;
< 
< }                               /* end real_sum_all_spin */
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
---
> /******/
2c2
<  **    $Id: my_mpi.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: my_mpi.c 1220 2011-01-27 23:59:08Z miro $    **
9d8
< #  if (AIX || LINUX || IRIX || XT3)
12,14c11
<     MPI_Barrier (pct.grid_comm);
<     /*MPI_Barrier (MPI_COMM_WORLD);*/
< 
---
>     MPI_Barrier (pct.thisgrp_comm);
16d12
< #  endif
30c26
<                      int MPI_SUM, int pct.grid_comm)
---
>                      int MPI_SUM, int pct.thisgrp_comm)
2c2
<  **    $Id: init.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: init.c 1164 2010-11-03 21:29:37Z froze $    **
66d65
<     REAL rho_buff[FP0_BASIS], rho_tot[FP0_BASIS];
89a89,95
>     /*Initialize ScaLapack, get context */
>     sl_init (&pct.ictxt, ct.num_states);
> 
>     /*Set desca, variable used in ScaLapack functions */
>     set_desca (pct.desca, &pct.ictxt, ct.num_states);
> 
> 
168c174
<         if (pct.imgpe == 0)
---
>         if (pct.thispe == 0)
311c317
<     printf ("\n\n init: Starting FFTW initialization ...");
---
> 	printf ("\n\n init: Starting FFTW initialization ...");
335c341
<     printf ("\n init: FFTW initialization finished, it took %.1f s", my_crtc () - time2);
---
> 	printf ("\n init: FFTW initialization finished, it took %.1f s", my_crtc () - time2);
373,389c379,381
<     {
< 	if (pct.spin_flag)
<         {
<        	    for (idx = 0; idx < FP0_BASIS; idx++)
< 	    {
< 	   	 rho[idx] = rhoc[idx]/2.0;
<            	 rho_buff[idx] = rhoc[idx]/2.0;
< 		 rho_tot[idx] = rho[idx] + rho_buff[idx];
< 	    }
< 
< 	}
< 	else
< 	{
<   	    for (idx = 0; idx < FP0_BASIS; idx++)
<             	rho[idx] = rhoc[idx];
< 	}
<     }
---
>         for (idx = 0; idx < FP0_BASIS; idx++)
>             rho[idx] = rhoc[idx];
> 
410,422c402,404
< 	if (pct.spin_flag)
< 	{
<         	get_vxc_spin (rho, rho_buff, rhocore, vxc);
<         	Dprintf ("get vxc completed");
<         	get_vh (rho_tot, rhoc, vh, 30, ct.poi_parm.levels);
< 	}
< 	else
< 	{
<         	get_vxc (rho, rhocore, vxc);
<         	Dprintf ("get vxc completed");
<         	get_vh (rho, rhoc, vh, 30, ct.poi_parm.levels);
< 	}
< 
---
>         get_vxc (rho, rhocore, vxc);
>         Dprintf ("get vxc completed");
>         get_vh (rho, rhoc, vh, 30, ct.poi_parm.levels);
2c2
<  **    $Id: neb_relax.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: neb_relax.c 1161 2010-10-26 23:18:51Z froze $    **
53a54
> 	REAL L_total, S_total, R_total;
109,110d109
< 			printf("\tNEB passed left wait.\n");
< 			fflush (NULL); fsync( fileno(ct.logfile) );
122,123d120
< 			printf("\tNEB passed right wait.\n");
< 			fflush (NULL); fsync( fileno(ct.logfile) );
125,126c122,143
<             /* calculate self force constraints from right and left data*/
<             for ( count = 0; count < ct.num_ions; count++ )
---
> 
> 			/* Set total energy for transfer */
> 			S_total = ct.TOTAL;
> 
>             if ( img_rank_map[LEFT] != MPI_PROC_NULL  ) 
> 			{
> 				MPI_Isend ( &S_total, 1, MPI_DOUBLE, img_rank_map[LEFT], LEFT, pct.img_topo_comm, &req[SELF] );
> 				MPI_Irecv ( &L_total, 1, MPI_DOUBLE, img_rank_map[LEFT], RIGHT, pct.img_topo_comm, &req[LEFT] );
> 			}
> 
>             if ( img_rank_map[RIGHT] != MPI_PROC_NULL  ) 
> 			{
> 				MPI_Isend ( &S_total, 1, MPI_DOUBLE, img_rank_map[RIGHT], RIGHT, pct.img_topo_comm, &req[SELF] );
> 				MPI_Irecv ( &R_total, 1, MPI_DOUBLE, img_rank_map[RIGHT], LEFT, pct.img_topo_comm, &req[RIGHT] );
> 			}
> 
> 			/* if data from left,wait; else use self data as left data */
>             if ( img_rank_map[LEFT] != MPI_PROC_NULL  ) 
> 			{
> 				MPI_Wait( &req[LEFT], &status );
> 			}
> 			else
128,142c145
<                 S_ptr[3*count + X] = R_ptr[3*count + X] - L_ptr[3*count + X];
<                 S_ptr[3*count + Y] = R_ptr[3*count + Y] - L_ptr[3*count + Y];
<                 S_ptr[3*count + Z] = R_ptr[3*count + Z] - L_ptr[3*count + Z];
< 
<                 tmp_mag = 0.0;
<                 tmp_mag += S_ptr[3*count + X]*S_ptr[3*count + X];
<                 tmp_mag += S_ptr[3*count + Y]*S_ptr[3*count + Y];
<                 tmp_mag += S_ptr[3*count + Z]*S_ptr[3*count + Z];
<                 if (tmp_mag != ZERO)
<                 {
<                     tmp_mag = sqrt (tmp_mag);
<                     S_ptr[3*count + X] /= tmp_mag;
<                     S_ptr[3*count + Y] /= tmp_mag;
<                     S_ptr[3*count + Z] /= tmp_mag;
<                 }
---
>                 L_total = S_total;
144,145d146
<         }
< 		printf("\tNEB push constraints to group PE's.\n");
147,157c148,156
<         /* broadcast force constraints to image procs */
<         MPI_Bcast( S_ptr, 3*ct.num_ions, MPI_DOUBLE, 0, pct.grid_comm );
< 
<         /* put force constraints into control structure */
<         for ( count = 0; count < ct.num_ions; count++ )
<         {
<             ct.ions[count].constraint[X] = S_ptr[3*count + X]; 
<             ct.ions[count].constraint[Y] = S_ptr[3*count + Y];
<             ct.ions[count].constraint[Z] = S_ptr[3*count + Z];
<             ct.ions[count].constraint_type = 1;
<         }
---
> 			/* if data from right,wait; else use self data as right data */
>             if ( img_rank_map[RIGHT] != MPI_PROC_NULL  ) 
> 			{
> 				MPI_Wait( &req[RIGHT], &status );
> 			}
> 			else
>             {
>                 R_total = S_total;
>             }
159,166d157
<         printf ("    Constrained per atom dynamics vector field.\n");
<         for (count = 0; count < ct.num_ions; count++)
<         {
<             printf ("       % 10f % 10f % 10f %d\n",
< 					ct.ions[count].constraint[0],
< 					ct.ions[count].constraint[1],
< 					ct.ions[count].constraint[2],
< 					ct.ions[count].constraint_type);
167a159,183
> 		/* broadcast force constraint parameters to image procs */
> 		MPI_Bcast( L_ptr, 3*ct.num_ions, MPI_DOUBLE, 0, pct.thisgrp_comm );
> 		MPI_Bcast( R_ptr, 3*ct.num_ions, MPI_DOUBLE, 0, pct.thisgrp_comm );
> 		MPI_Bcast( &L_total, 1, MPI_DOUBLE, 0, pct.thisgrp_comm );
> 		MPI_Bcast( &R_total, 1, MPI_DOUBLE, 0, pct.thisgrp_comm );
> 
> 		/* capture force constraint parameters from right and left data*/
> 		for ( count = 0; count < ct.num_ions; count++ )
> 		{
> 			/* put force constraints into control structure */
> 			ct.ions[count].constraint.setA_weight = L_total;
> 			ct.ions[count].constraint.setA_coord[X] = L_ptr[3*count + X]; 
> 			ct.ions[count].constraint.setA_coord[Y] = L_ptr[3*count + Y]; 
> 			ct.ions[count].constraint.setA_coord[Z] = L_ptr[3*count + Z]; 
> 
> 			ct.ions[count].constraint.setB_weight = R_total;
> 			ct.ions[count].constraint.setB_coord[X] = R_ptr[3*count + X]; 
> 			ct.ions[count].constraint.setB_coord[Y] = R_ptr[3*count + Y]; 
> 			ct.ions[count].constraint.setB_coord[Z] = R_ptr[3*count + Z]; 
> 
> 			/* zero velocities for every nudge */
> 			ct.ions[count].velocity[0] = 0.0;
> 			ct.ions[count].velocity[1] = 0.0;
> 			ct.ions[count].velocity[2] = 0.0;
> 		}
169d184
< 		printf("\tNEB call fast relax.\n");
170a186,189
> 		MPI_Barrier( MPI_COMM_WORLD );
> 		printf("\tNEB call fast relax.\n");
> 		fflush(NULL);fsync( fileno(ct.logfile) );
> 		MPI_Allreduce( &tmp_mag, &max_frc, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
172d190
< 		printf("\tNEB finished fast relax.\n");
186a205,206
> 		fflush(NULL);fsync( fileno(ct.logfile) );
> 
187a208
> 
189a211
> 
192c214,215
<         //MPI_Bcast( &max_frc, 1, MPI_DOUBLE, 0, pct.grid_comm );
---
> 		
>         MPI_Bcast( &max_frc, 1, MPI_DOUBLE, 0, pct.thisgrp_comm );
194,195c217,219
<         CONV_FORCE = (max_frc > ct.thr_frc * ct.thr_frc);
< 		printf("\tNEB are we converged? If no, continue.\n");
---
>         CONV_FORCE = (max_frc < ct.thr_frc * ct.thr_frc);
> 		printf("\nNEB is max_frc^2:%f < ct.thr_frc^2:%f ? If so, DONE.\n", max_frc, ct.thr_frc*ct.thr_frc);
> 		printf("\nNEB is neb_steps:%d== max_rmg_steps:%d ? If so, DONE.\n", neb_steps, ct.max_rmg_steps);
2c2
<  **    $Id: pack_doubles.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: pack_doubles.c 1065 2009-08-31 16:23:01Z froze $    **
49c49
<  *                 MPI_BYTE, nb_ids[NB_D], 1, pct.grid_comm, &mstatus);
---
>  *                 MPI_BYTE, nb_ids[NB_D], 1, pct.thisgrp_comm, &mstatus);
2c2
<  **    $Id: get_te.c 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: get_te.c 1066 2009-08-31 18:41:09Z froze $    **
53c53
<     REAL *exc, *nrho, *nrho_buff;
---
>     REAL *exc, *nrho;
90d89
<     {
92d90
<     }
94,95c92
<     
<  
---
> 
101,104c98
<         /* exclda_pz81 (nrho, exc); */
< 
< 	/* incoporate both the Perdew Zunger 1981 and Ortiz Ballone 1994, default is PZ 1981 */
<         xclda (nrho, vxc, exc);
---
>         exclda_pz81 (nrho, exc);
121c115
< 	break;
---
>         break;
2c2
<  **    $Id: force.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: force.c 1161 2010-10-26 23:18:51Z froze $    **
95c95
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
119c119
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
152c152
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
187c187
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
219c219
<     if (pct.imgpe == 0)
---
>     if (pct.thispe == 0)
250,256c250,251
<     if (verify ("atom_constraints", NULL))
<     {
<         for (ion = 0; ion < ct.num_ions; ion++)
<         {
<             constrain (&ct.ions[ion]);
<         }
<     }
---
>     if( ct.constrainforces )
>         constrain ();
2c2
<  **    $Id: init_img_topo.c 1152 2010-10-13 22:30:19Z froze $    **
---
>  **    $Id: init_img_topo.c 1125 2010-05-28 04:49:32Z froze $    **
24c24
<             dims[0] = pct.images;
---
>             dims[0] = pct.instances;
28c28
<     MPI_Cart_create ( pct.rmg_comm, ndims, dims, periods, 1, &pct.img_topo_comm );
---
>     MPI_Cart_create ( pct.master_comm, ndims, dims, periods, 1, &pct.img_topo_comm );
2c2
<  **    $Id: quench.c 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: quench.c 1123 2010-05-19 20:03:04Z froze $    **
64c64
<         if (pct.imgpe == 0)
---
>         if (pct.thispe == 0)
2c2
<  **    $Id: real_min_all.c 1151 2010-10-11 21:24:18Z froze $    **
---
>  **    $Id: real_min_all.c 1066 2009-08-31 18:41:09Z froze $    **
52c52
<     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_MIN, pct.grid_comm);
---
>     MPI_Allreduce (&inreg, &outreg, 1, MPI_DOUBLE, MPI_MIN, pct.thisgrp_comm);
2c2
< #**    $Id: Make.aix 1117 2010-04-19 16:13:54Z froze $    **
---
> #**    $Id: Make.aix 1234 2011-02-01 17:16:38Z luw $    **
16c16
< MODULES = Common Input
---
> MODULES = Common Input ../Common/*
2c2
< #**    $Id: Make.linux 1199 2011-01-21 20:58:27Z yanli $    **
---
> #**    $Id: Make.linux 1234 2011-02-01 17:16:38Z luw $    **
19c19
< MODULES = Common Input Spin Spin/XC
---
> MODULES = Common Input ../Common/*
143,146d142
< #Whether Pulay (anderson) mixing should be used instead of linear mixing
< #This option is still experimental and will not do anything unless PULAY compile flag
< #is turned in at the compile time
< pulay_mixing="false"
176a173,180
> # Type of mixing for charge density
> # Linear (steepest descent) or Pulay
> # Default: Linear
> charge_mixing_type=
> "Linear"
> #"Pulay"
> 
> # Amount of charge density mixing when linear mixing is used
179a184,212
> # Order of Pulay for charge density mixing
> # Default: "5"
> charge_pulay_order="5"
> 
> # How often to refresh Pulay mixing
> # It is often beneficial to scrap Pulay history and start over,
> # with this parameter it can be done periodically every few steps
> # Set it to zero to never refresh
> # Default: 0
> charge_pulay_refresh="0"
> 
> # Scale parameter for residual in Pulay charge density mixing
> # Reasonable values are around 0.5
> # Default: 0.25 (0.5) may give better results
> charge_pulay_scale="0.25"
> 
> # Whether or not to use special metrics for calculating dot products in Pulay mixing
> # This should presumably help convergence for systems with many states close to Fermi level
> # Reference: J Enkovaara et al 2010 J. Phys.: Condens. Matter 22 253202
> # Default: "false"
> charge_pulay_special_metrics=
> "false"
> #"true"
> 
> # Weight for the Pulay special metrics
> # Default: "100.0"
> # 50 may also be tried, if default does not work
> charge_pulay_special_metrics_weight="100"
> 
446a480,486
> 
> # Whether the actual ionic masses or equal masses for all ions (set to that of carbon)
> # should be used for fastrelax. The ionic masses appear to work better and are better tested. 
> # Default: "Atomic"
> fastrelax_mass=
> "Atomic"
> #"Equal"
Only in ../ultrasoft/./Headers: blacs.h
diff ./Headers/blas.h ../ultrasoft/./Headers/blas.h
2c2
<  **    $Id: blas.h 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: blas.h 1220 2011-01-27 23:59:08Z miro $    **
45c45
< #if (LINUX || IRIX || XT3)
---
> #ifdef LINUX 
67d66
< #  define               exchlsd         exchlsd_
83c82,83
< #elif AIX
---
> #else
> #ifdef AIX
100,130c100
< #elif UNICOS_T3E
< 
< #  define		saxpy		SAXPY
< #  define		scopy   	SCOPY
< #  define		sdot    	SDOT
< #  define		sscal   	SSCAL
< #  define		snrm2   	SNRM2
< #  define		sswap   	SSWAP
< #  define		spotrf  	SPOTRF
< #  define		spotri  	SPOTRI
< #  define		ssyev   	SSYEV
< #  define		global_sums 	GLOBAL_SUMS
< #  define		ilaenv  	ILAENV
< #  define		app_del2f  	APP_DEL2F
< #  define		xbecke    	XBECKE
< #  define		corlyp_f90      corlyp_f90_
< #  define		exch      	EXCH
< #  define		corlsd    	CORLSD
< #  define               exchlsd         EXCHLSD
< #  define		corgga    	CORGGA
< #  define		corpbe    	CORPBE
< #  define		exchpbe   	EXCHPBE
< #  define		symrho    	SYMRHO
< #  define		symmetry  	SYMMETRY
< #  define		fsymforces 	FSYMFORCES
< #  define       cpotrf     	CPOTRF
< #  define       cpotri     	CPOTRI
< #  define       cheev      	CHEEV
< #  define       fgram      	FGRAM
< #  define		latgen 	   	LATGEN
< 
---
> #endif
152d121
< void exchlsd (REAL *rho, REAL * ex, REAL * vx );
159a129
> void cpotrf (char *uplo, int *n, REAL * a, int *lda, int *info);
180,184d149
< 
< 
< #ifndef UNICOS_T3E
< void cpotrf (char *uplo, int *n, REAL * a, int *lda, int *info);
< #endif
diff ./Headers/const.h ../ultrasoft/./Headers/const.h
2c2
<  **    $Id: const.h 1123 2010-05-19 20:03:04Z froze $    **
---
>  **    $Id: const.h 1241 2011-02-01 23:45:44Z miro $    **
145a146,284
> 
> 
> 
> /* Some stuff for timing and performance measurements */
> #define TOTAL_TIME (0)
> #define ORTHO_TIME (1)
> //#define NL_TIME (2)
> //#define NS_TIME (3)
> #define EIG_TIME (4)
> #define IMAGE_TIME (5)
> //#define APPCIL_TIME (6)
> //#define APPCIR_TIME (7)
> #define RESTRICT_TIME (8)
> #define EXPAND_TIME (9)
> #define PACK_TIME (10)
> #define INIT_TIME (11)
> #define HARTREE_TIME (12)
> #define DIAG_TIME (13)
> #define LFORCE_TIME (14)
> #define NLFORCE_TIME (15)
> #define APPGRAD_TIME (16)
> #define GATHER_TIME (17)
> #define MG_EIGTIME (18)
> #define INTERPOLATION_TIME (19)
> #define RHO_TIME (20)
> #define FORCE_TIME (21)
> #define SCF_TIME (22)
> //#define MD_LOOP (23)
> #define NLCCFORCE_TIME (24)
> #define IIFORCE_TIME (25)
> #define MG_EIG_NLS_TIME (26)
> #define MG_EIG_APPCIL_TIME (27)
> #define MG_EIG_APPCIR_TIME (28)
> #define MG_EIG_TRADE_TIME (29)
> #define DIAG_NL_TIME (30)
> #define DIAG_APPCIL_TIME (31)
> #define DIAG_APPCIR_TIME (32)
> #define GET_TE_XC_TIME (33)
> #define GET_TE_II_TIME (34)
> #define GET_TE_TIME (35)
> #define SCF_XC_TIME (36)
> #define INTERP_SETUP_TIME (37)
> #define INTERP_EVAL_TIME (38)
> #define DIAG_SUBDIAG1_TIME (39)
> #define DIAG_MATRIX_TIME (40)
> #define DIAG_WAVEUP_TIME (41)
> #define DIAG_SUBDIAG1_LOOP_TIME (42)
> #define DIAG_APP_A (43)
> #define DIAG_APP_S (44)
> #define DIAG_APP_B (45)
> #define DIAG_DGEMM (46)
> #define DIAG_GENVPSI_TIME (47)
> #define DIAG_GLOB_SUMS (48)
> #define DIAG_BETAXPSI (49)
> #define ALLOC_TIME (50)
> #define ORTHO_BETAXPSI (51)
> #define ORTHO_NORM_PSI (52)
> #define ORTHO_NEW_PSI (53)
> #define ORTHO_GET_COEFF (54)
> #define ORTHO_GLOB_SUM (55)
> #define ORTHO_UPDATE_WAVES (56)
> #define DIAG_APPCIR_TIME2 (57)
> #define MG_EIG_GENVPSI_TIME (58)
> #define MG_EIG_EIGVALUE_TIME (59)
> #define MG_EIG_APPSMOOTH_TIME (60)
> #define MG_EIG_MGRIDSOLV_TIME (61)
> #define MG_EIG_PACK_TIME (62)
> #define DIAG_NLS_TIME (63)
> #define PREINIT_TIME (64)
> #define FINISH_TIME (65)
> #define DIAG_SCALAPACK_INIT (66)
> #define DIAG_DISTMAT (67)
> #define REAL_SUM_ALL_TIME (68)
> #define GLOBAL_SUMS_TIME (69)
> #define DIAG_BCAST_EIGS (70)
> #define READ_PSEUDO_TIME 71
> #define READ_CONTROL_TIME 72
> 
> #define LAST_TIME (80)
> 
> 
> /* Occupation flags */
> #define OCC_NONE 0
> #define OCC_FD 1
> #define OCC_GS 2
> #define OCC_EF 3
> 
> 
> /* SMP directives for the threads */
> #define     SMP_EIG       1
> #define     SMP_ORTHO1    2
> #define     SMP_ORTHO2    3
> #define     SMP_GET_RHO   4
> #define     SMP_SORT_PSI  5
> #define     SMP_SKIP      6
> #define     SMP_DIAG1     7
> #define     SMP_DIAG2     8
> #define     SMP_NLFORCE   9
> #define     SMP_GETNLOP  10
> 
> 
> /* Crystal lattice types */
> /** Simple cubic lattice type.
>  *  @doc Set input file value = 1 */
> #define CUBIC_PRIMITIVE 	1
> 
> /** Face centered cubic lattice type. 
>  *  @doc Set input file value = 2 */
> #define CUBIC_FC		2
> 
> /** Bodycentered cubic lattice type. 
>  *  @doc Set input file value = 3 */
> #define CUBIC_BC		3
> 
> /** Hexagonal lattice type. 
>  *  @doc Set input file value = 4 */
> #define HEXAGONAL		4
> 
> #define TRIGONAL_PRIMITIVE	5
> #define TETRAGONAL_PRIMITIVE	6
> #define TETRAGONAL_BC           7
> 
> /** Orthorhombic lattice type. 
>  *  @doc Set input file value = 8 */
> #define ORTHORHOMBIC_PRIMITIVE  8
> 
> #define ORTHORHOMBIC_BASE_CENTRED 9
> #define ORTHORHOMBIC_BC         10
> #define ORTHORHOMBIC_FC 11
> #define MONOCLINIC_PRIMITIVE 12
> #define MONOCLINIC_BASE_CENTRED 13
> #define TRICLINIC_PRIMITIVE 14
> 
> /* The real or imaginary part of a wavefunction */
> #define PSI_REAL     0
> #define PSI_IMAG     1
> 
> 
> 
Only in ../ultrasoft/./Headers: fftw.h
diff ./Headers/input.h ../ultrasoft/./Headers/input.h
2c2
<  *  **    $Id: input.h 1123 2010-05-19 20:03:04Z froze $    **
---
>  *  **    $Id: input.h 1212 2011-01-25 18:52:03Z froze $    **
94a95
> int      sstripcmnt (char *string, const char delim);
diff ./Headers/macros.h ../ultrasoft/./Headers/macros.h
2c2
<  **    $Id: macros.h 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: macros.h 1143 2010-09-24 17:42:02Z froze $    **
32,34c32
< //#define dprintf( format, args...) fprintf (stderr, "\n#WARNING from IMG PE %d in IMG %d  of grid rank %d of spin %d:    \t"format"\n", pct.imgpe, pct.thisimg, pct.thispe, pct.thisspin,  ##args), fflush(NULL)
< #define dprintf( format, args...) fprintf (stderr, "\ngrid rank %d of spin %d:    \t"format"\n", pct.thispe, pct.thisspin,  ##args), fflush(NULL)
< 
---
> #define dprintf( message... ) fprintf( stderr, message )
46,47c44
< 	 ((pct.imgpe == 0) ? fprintf( ct.logfile, message ): 0)
< 	
---
> 	 ((pct.thispe == 0) ? fprintf( ct.logfile, message ): 0)
51,52c48,49
<     fprintf (stderr, "\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisimg+1, __FILE__, __LINE__, pct.thispe), \
<     printf ("\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisimg+1, __FILE__, __LINE__, pct.thispe), \
---
>     fprintf (stderr, "\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisgrp+1, __FILE__, __LINE__, pct.thispe), \
>     printf ("\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisgrp+1, __FILE__, __LINE__, pct.thispe), \
diff ./Headers/main.h ../ultrasoft/./Headers/main.h
2c2
<  **    $Id: main.h 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: main.h 1241 2011-02-01 23:45:44Z miro $    **
57d56
< 
68a68,70
> /* include scalapack wrapper */
> #include "my_scalapack.h"
> 
72,1369d73
< #ifdef SMP
< #  include <pthread.h>
< #  include <semaphore.h>
< 
< typedef struct
< {
<     volatile int count;
<     pthread_mutex_t mutex;
<     pthread_cond_t cond;
< } QMD_thread_barrier_struct;
< 
< void QMD_thread_barrier (QMD_thread_barrier_struct * bs);
< 
< #  if (AIX || LINUX || XT3)
< typedef struct
< {
<     pthread_mutex_t lock;
<     pthread_cond_t cond;
<     int count;
< } QMD_sem_t;
< #  else
< typedef struct
< {
<     sem_t sem;
< } QMD_sem_t;
< #  endif
< #endif
< 
< 
< #if MPI
< typedef struct
< {
<     int count;
< } QMD_sem_t;
< #endif
< 
< /* Processor grid storage on finest level */
< typedef struct
< {
< 
<     REAL b[PX0_GRID][PY0_GRID][PZ0_GRID];
< 
< } P0_GRID_S;
< 
< 
< /* Here we use a union of P0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
< 
<     P0_GRID_S s1;
<     REAL s2[PX0_GRID * PY0_GRID * PZ0_GRID];
< 
< } P0_GRID;
< 
< /* Processor grid storage on finest level on the Fine Grid*/
< typedef struct
< {
< 
<     REAL b[FPX0_GRID][FPY0_GRID][FPZ0_GRID];
< 
< } FP0_GRID_S;
< 
< 
< /* Here we use a union of FP0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
<     FP0_GRID_S s1;
<     REAL s2[FPX0_GRID * FPY0_GRID * FPZ0_GRID];
< 
< } FP0_GRID;
< 
< 
< /* Smoothing grid storage on finest level */
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 2][PY0_GRID + 2][PZ0_GRID + 2];
< 
< } S0_GRID_S;
< 
< 
< /* Here we use a union of S0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
< 
<     S0_GRID_S s1;
<     REAL s2[(PX0_GRID + 2) * (PY0_GRID + 2) * (PZ0_GRID + 2)];
< 
< } S0_GRID;
< 
< /* Smoothing grid storage on finest level on the Fine Grid*/
< typedef struct
< {
< 
<     REAL b[FPX0_GRID + 2][FPY0_GRID + 2][FPZ0_GRID + 2];
< 
< } FS0_GRID_S;
< 
< /* Here we use a union of FS0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
< 
<     FS0_GRID_S s1;
<     REAL s2[(FPX0_GRID + 2) * (FPY0_GRID + 2) * (FPZ0_GRID + 2)];
< 
< } FS0_GRID;
< 
< 
< /* For applying higher order finite difference operators */
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 4][PY0_GRID + 4][PZ0_GRID + 4];
< 
< } SS0_GRID;
< 
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 6][PY0_GRID + 6][PZ0_GRID + 6];
< 
< } S30_GRID;
< 
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 10][PY0_GRID + 10][PZ0_GRID + 10];
< 
< } S50_GRID;
< 
< 
< typedef struct
< {
< 
<     REAL b[FPX0_GRID + 4][FPY0_GRID + 4][FPZ0_GRID + 4];
< 
< } FSS0_GRID;
< 
< 
< /** @name PE_CONTROL
<   *
<   * @memo Processor control structure.
<   * 
<   * This is a global structure declared as extern PE_CONTROL pct.
<   * 
<  */
< typedef struct
< {
< 
<     /** Number (rank in MPI terminology) of this processor in this image grid */
<     int thispe, imgpe, thisimg, thisspin, thisgrid;
< 
< 	/** Number of grids (typically 1) per image to be run simultaneously **/
< 	int images, grids;
< 
< 	/* MPI communicators for each code grid (grid_comm) and one (rmg_comm)
< 	 * for all group rank 0 pe's. The later effectively replaces MPI_COMM_WORLD
< 	 * unless you really need all-to-all, even across grids, communication. */
< 	MPI_Comm rmg_comm, img_topo_comm, grid_topo_comm, grid_comm, img_comm, spin_comm;
< 
<     /* determine if this image is processing spin up or spin down. */
<     int spin_flag;
< 
<     /* determine whether to initialize up and down density equally or not */
<     int init_equal_density_flag;
< 
<     /*Whether pe participates in scalapack calculations*/
<     int scalapack_pe;
< 
<     /* Row that given processor handles when using scalapack*/
<     int scalapack_myrow;
<     
<     /* Column that given processor handles when using scalapack*/
<     int scalapack_mycol;
< 
<     /*Processor distribution for scalapack*/
<     int scalapack_nprow;
<     int scalapack_npcol;
< 
<     /** Neighboring processors in three-dimensional space */
<     int neighbors[6];
< 
< 
<     /** Processor x-coordinate for domain decomposition */
<     int pe_x;
<     /** Processor y-coordinate for domain decomposition */
<     int pe_y;
<     /** Processor z-coordinate for domain decomposition */
<     int pe_z;
< 
< 
<     /** Points to start of projector storage for this ion in projector space */
<     //REAL *weight[MAX_IONS];
<     REAL **weight;
< 
< #if FDIFF_BETA
<     /*These are used for non-local force */
<     //REAL *weight_derx[MAX_IONS];
<     REAL **weight_derx;
<     //REAL *weight_dery[MAX_IONS];
<     REAL **weight_dery;
<     //REAL *weight_derz[MAX_IONS];
<     REAL **weight_derz;
< #endif
< 
< 
<     /** An index array which maps the projectors onto the 3-d grid associated
<         with each processor.
<     */
<     //int *nlindex[MAX_IONS];
<     int **nlindex;
<     //int *Qindex[MAX_IONS];
<     int **Qindex;
< 
<     /** An index array which indicate whether the grid map on the current pocessor*/
<     //int *idxflag[MAX_IONS];
<     int **idxflag;
<     //int *Qdvec[MAX_IONS];
<     int **Qdvec;
< 
<     /** Number of points in the nlindex array for each ion */
<     //int idxptrlen[MAX_IONS];
<     int *idxptrlen;
<     //int Qidxptrlen[MAX_IONS];
<     int *Qidxptrlen;
< 
<     /** Number of points in the circle of local projector for each pocessor*/
<     //int lptrlen[MAX_IONS];
<     int *lptrlen;
< 
<     /** Phase shifts for the non-local operators */
<     //REAL *phaseptr[MAX_IONS];
<     REAL **phaseptr;
< 
<     /** Number of projectors associated with each ion. */
<     //int prj_per_ion[MAX_IONS];
<     int *prj_per_ion;
< 
<     /** Points to start of storage for theaugument function*/
<     //REAL *augfunc[MAX_IONS];
<     REAL **augfunc;
< 
<     /** points to start of DnmI function storage for this ion*/
<     //REAL *dnmI[MAX_IONS];
<     REAL **dnmI;
< 
<     /** points to start of qqq storage for this ion*/
<     //REAL *qqq[MAX_IONS];
<     REAL **qqq;
< } PE_CONTROL;
< 
< 
< 
< /**@name STATE
<  *
<  * @memo Wavefunction storage structure */
< typedef struct
< {
< 
<     /** First iteration flag */
<     int firstflag;
< 
<     /** Current estimate of the eigenvalue for this orbital (state). */
<     REAL eig;
< 
<     /** Wavefunction residual error computed by multigrid solver */
<     REAL res;
< 
<     /** Points to the storage area for the real part of the orbital */
<     REAL *psiR;
<     /** Points to the storage area for the imaginary part of the orbital */
<     REAL *psiI;
< 
< 
<     /** Nuclear potential */
<     REAL *vnuc;
<     /** Hartree potential */
<     REAL *vh;
<     /** Exchange correlation potential */
<     REAL *vxc;
<     /** Total potential */
<     REAL *vtot;
< 
<     /** Core charge for non-linear core corrections */
<     REAL *rhocore;
< 
<     /** Grid dimension in the x-coordinate direction on this processor */
<     int dimx;
<     /** Grid dimension in the y-coordinate direction on this processor */
<     int dimy;
<     /** Grid dimension in the z-coordinate direction on this processor */
<     int dimz;
< 
< 
<     /** Grid spacings */
<     REAL hxgrid;
<     REAL hygrid;
<     REAL hzgrid;
< 
< 
<     /** Total basis size on each processor (dimx*dimy*dimz) */
<     int pbasis;
< 
<     /* Total basis size in a smoothing grid on each processor (dimx+2)*(dimy+2)*(dimz+2) */
<     int sbasis;
< 
<     /*8 Index of the orbital */
<     int istate;
< 
< 
<     /** Volume element associated with each real space grid point */
<     REAL vel;
< 
< 
<     /** Occupation of the orbital */
<     REAL occupation;
< 
<     REAL oldeig;
< 
<     /* The offsets and the sizes of the grid that the orbital
<      * is defined on relative to the global grid. These will
<      * be used in the future for cluster boundary condition or
<      * localized orbitals in an Order(N) formulation.
<      */
<     int xoff, yoff, zoff;
<     int xsize, ysize, zsize;
< 
<     /** Index showing which k-point this orbital is associated with */
<     int kidx;
< 
<     /* eigenvalue of the opposite spin for the corresponding orbital (state)*/
<     REAL eig_oppo;
< 
<     /* Hold occupation of the opposite spins orbital*/
<     REAL occupation_oppo;
< 
< } STATE;
< 
< 
< /**@name SPECIES
<  * @memo Species (pseudopotential) control structure
<  * @doc Structure holds data about the pseudopotentials used to
<  * represent different types of atomic species. 
< */
< typedef struct
< {
< 
<     /* symbol read from control file */
<     char pseudo_symbol[32];
< 
<     /* pseudopotential filename */
<     char pseudo_filename[MAX_PATH];
< 
<     /** Description of the species (e.g Atomic carbon generated using 
<      * hamann's code with  rcs=0.80 rcp=0.85 bohr
<      */
<     char description[MAX_CHAR];
< 
<     /** Atomic number */
<     int atomic_number;
< 
<     /** Atomic symbol */
<     char *atomic_symbol;
< 
<     /** Atomic mass */
<     REAL atomic_mass;
< 
<     /** Number of valence electrons */
<     REAL zvalence;
< 
<     /** Gaussian charge parameter used for compensating the 1/r Coulomb
<      * tail of the pseudopotentials
<      */
< 
<     REAL rc;
< 
<     /* Number of grid points in the local in each coordinate direction. 
<      * These used to be L0_LDIM and L0_NLDIM.
<      */
<     int ldim;
<     int nldim;
<     int nlfdim;
<     int qdim;
< 
< 
<     /* These are input parameters in the pseudopotential file. They represent the
<      * real radii that are used in generating ldim and nldim.
<      */
<     REAL lradius;
<     REAL nlradius;
<     REAL qradius;
< 
<     /*Radius for milliken analysis*/
<     REAL mill_radius;
<     /*Radius in number of grid points*/
<     int mill_dim;
<     /*Number of radial atomic wave functions - these depend on l only, not on m*/
<     int num_atomic_waves;
<     /*l-numbers for states for which we have atomic orbitals*/
<     int lstate_atomic_wave[5];
<     /*Sum of all atomic states (with different l or m numbers*/
<     int sum_atomic_waves;
< 
<     /*This will store name of atomic wavefunctions, such as s, px, py, pz, dxx etc*/
<     char atomic_wave_symbol[20][12];
< 
< 
<     /** Number of radial grid points in the pseudopotential file */
<     int rg_points;
< 
<     /* Log mesh parameter, where aa=exp(-aasf)/Z, bb=1.0/bbsf */
<     REAL aa, bb;
< 
<     /** Non-linear core correction flag */
<     int nlccflag;
< 
<     /* Number of potentials */
<     int num_potentials;
< 
<     /* L-values for the reference states */
<     int lval[10];
< 
<     /* L-value for local pseudopotential state */
<     int local;
< 
<     /* Index for local pseudopotential state */
<     int localidx;
< 
<     /*Number of grid points in the beta function */
<     int kkbeta;
< 
<     /*matrix ddd0(nbeta,nbeta) */
<     REAL ddd0[18][18];
<     REAL ddd[18][18];
< 
<     /*matrix qqq(nbeta,nbeta) */
<     REAL qqq[18][18];
< 
<     /*the number of L=|l1-l2|.....|l1+l2|, we limit nlc <=5 */
<     int nlc;
< 
<     /*the number of component in polynomial of the pseudized Q_I(r) function we limit nqf<=10 */
<     int nqf;
< 
<     /*L-independent inner coutoff radii rinner for Q_I(r) function */
<     REAL rinner[5];
< 
<     /* ultrosoft Vanderbilt Qnm_rad(r) function and */
<     REAL *qnm;
<     REAL *qnmlig;
<     REAL *drqnmlig;
< 
<     /* the coefficient for pseudosation of Qnm_L(r) */
<     REAL *qfcoef;
< 
<     /* Logarithmic radial mesh information */
<     REAL r[MAX_RGRID];
<     REAL rab[MAX_RGRID];
< 
< 
<     /* Local Pseudopotentials */
<     REAL vloc0[MAX_RGRID];
< 
<     /* Core charge radial grids */
<     REAL cr[MAX_RGRID];
< 
< 
<     /* Pseudo atomic valence density */
<     /*REAL avdens[MAX_RGRID];*/
<     REAL **atomic_wave;
< 
< 
<     /* Pseudo atomic core density */
<     REAL rspsco[MAX_RGRID];
< 
<     /*the L-value for the beta function */
<     int llbeta[MAX_NB];
< 
<     /*utrosoft Vanderbilt beta_n(r) function on radial grid */
<     REAL beta[MAX_NB][MAX_RGRID];
< 
< 
<     /* Total number of projectors */
<     int nbeta;
< 
< 
<     /* Linear interpolation storage for the compensated local potential
<      * and for it's radial derivative.
<      */
<     REAL localig[MAX_LOCAL_LIG];
<     REAL drlocalig[MAX_LOCAL_LIG];
< 
<     /* Linear interpolation storage for the core charge density */
<     REAL rhocorelig[MAX_LOCAL_LIG];
< 
<     /* Utrosoft Vandbelit Projectors on linear interpolation grid */
<     REAL betalig[MAX_NB][MAX_LOCAL_LIG];
< 
<     /* Radial derivatives of the Utrosoft Vandbelit Projectors on linear interpolation grid */
<     REAL drbetalig[MAX_NB][MAX_LOCAL_LIG];
< 
<     /* Local potential linear interpolation grid spacing */
<     REAL drlig;
< 
<     /* Non-local linear interpolation grid spacing */
<     REAL drnlig;
< 
<     /* Qfunction linear interpolation grid spacing */
<     REAL drqlig;
< 
< 
<     /* Pseudopotential filtering parameters */
<     REAL lrcut;                 /* Real space local cutoff */
<     REAL nlrcut[4];             /*Real space nonlocal cutoff */
<     REAL rwidth;                /* Real-space width parameter */
<     REAL gwidth;                /* G-space width parameter */
< 
< 
<     /*Total number (of what exactly ???) */
<     int num_projectors;
< 
< 
<     /*This will store results of forward fourier transform on the coarse grid */
<     fftw_complex *forward_beta;
< 
< #if !FDIFF_BETA
<     /*This will store results of forward fourier transform for derivatives of beta on the coarse grid */
<     fftw_complex *forward_derbeta_x;
<     fftw_complex *forward_derbeta_y;
<     fftw_complex *forward_derbeta_z;
< #endif
< 
<     /*Backwards wisdom for fftw */
<     char *backward_wisdom;
< 
< 
< } SPECIES;
< 
< 
< /* Structure for storing species information for internal pseudopotentials */
< typedef struct
< {
<     char name[4];
<     REAL valence;
<     REAL mass;
<     REAL rc;
<     int nlccflag;
<     int maxl;
<     int local;
< } ISPECIES;
< 
< 
< 
< /*Structure for storing PDB information
<  * Each ion should have it*/
< typedef struct
< {
< 
< /* 1 -  6  Record name*/
< char record_name[7];
< 
< /* 7 - 11 Atom serial number*/
< int serial_num;
< 
< /*13 - 16  Atom name*/
< char name[5];
< 
< /* 17 Alternate location indicator.*/
< char altLoc[2];
< 
< /* 18 - 20 Residue name*/
< char resName[4];
< 
< /* 22 Chain identifier*/
< char chainID[2];
< 
< /* 23 - 26 Residue sequence number*/
< int resSeq;
< 
< /* 27 Code for insertion of residues*/
< char iCode[2];
< 
< /* 55 - 60 Occupancy*/
< REAL occupancy;
< 
< /* 61 - 66 Temperature factor*/
< REAL tempFactor;
< 
< /* 77 - 78  Element symbol, right-justified. */
< char element[3];
< 
< /*79 - 80  Charge on the atom.*/
< char charge[3];
< 
< } PDB_INFO;
< 
< 
< 
< 
< /* Ion structure */
< typedef struct
< {
< 
<     /* Initial physical coordinates at start of run */
<     REAL icrds[3];
< 
<     /* Actual Physical coordinates at current time step */
<     REAL crds[3];
< 
<     /* Positions at the previous time step */
<     REAL ocrds[3];
< 
<     /* Initial crystal coordinates at start of run */
<     REAL ixtal[3];
< 
<     /* Actual crystal coordinates at current time step */
<     REAL xtal[3];
< 
<     /* Crystal coordinates  at the previous time step */
<     REAL oxtal[3];
< 
<     /*Position of ion relative to the middle of non-local box around the ion 
<      *          * determined in get_nlop, AIget_cindex sets this up*/
<     REAL nlcrds[3];
< 
< 
<     /* Coordinates of the corner of the grid that the local */
<     /* difference potential is nonzero on.                  */
<     REAL lxcstart;
<     REAL lycstart;
<     REAL lzcstart;
< 
< 
<     /* Coordinates of the corner of the grid that the non-local */
<     /* potential is nonzero on.                                 */
<     REAL nlxcstart;
<     REAL nlycstart;
<     REAL nlzcstart;
< 
< 
<     /* Coordinates of the corner of the grid that the Qfunction */
<     /* potential is nonzero on.                                 */
<     REAL Qxcstart;
<     REAL Qycstart;
<     REAL Qzcstart;
< 
< 
<     /* Integer species type when using a raw pseudopotential */
<     int species;
< 
<     /* Forces on the ion */
<     REAL force[4][3];
< 
<     /* Current velocity of the ion */
<     REAL velocity[3];
< 
<     /* Kleinman-Bylander normalization coefficients */
<     REAL pd[(MAX_L + 1) * (MAX_L + 1)];
< 
<     /* Milliken normalization coefficients */
<     REAL mnorm[(MAX_L + 1) * (MAX_L + 1)];
< 
<     /* Total number of projectors */
<     int prjcount;
< 
<     /* Movable flag */
<     int movable;
< 
< 	/* Movement constraint: float[3] vector, int constraint_type (0=disabled, 1=in-plane, 2=along vector) */
< 	REAL constraint[3];
< 	int constraint_type;
< 
<     /* Stored non-local projectors */
<     REAL *oldsintR;
<     REAL *oldsintI;
<     REAL *newsintR;
<     REAL *newsintI;
< 
<     /* Stores sine and cosine of a phase factor for backwards fourier transform */
<     REAL *fftw_phase_sin;
<     REAL *fftw_phase_cos;
< 
< 
<     /*Stores PDB information*/
<     PDB_INFO pdb;
< 
< 
< } ION;
< 
< 
< 
< /* multigrid-parameter structure */
< typedef struct
< {
< 
<     /* number of global-grid pre/post smoothings and timestep */
<     REAL gl_step;
<     int gl_pre;
<     int gl_pst;
< 
<     /* timestep for the subiteration */
<     REAL sb_step;
< 
<     /* timestep for the Richardson-Iteration */
<     REAL ri_step;
< 
<     /* lowest MG level */
<     int levels;
< 
< 
< } MG_PARM;
< 
< /* Nose control structure */
< typedef struct
< {
< 
<     /* number of atoms allowed to move */
<     int N;
< 
<     /* ionic target temperature in Kelvin */
<     REAL temp;
< 
<     /* ionic target kinetic energy */
<     REAL k0;
< 
<     /* randomize velocity flag */
<     int randomvel;
< 
<     /* Nose oscillation frequency */
<     REAL fNose;
< 
<     /* number of thermostats used */
<     int m;
< 
<     /* thermostat positions,velocities,masses and forces */
<     REAL xx[10];
<     REAL xv[10];
<     REAL xq[10];
<     REAL xf[4][10];
< 
< } FINITE_T_PARM;
< 
< 
< /** @name KPOINT
<  * @memo Holds data specific to individual k-points.
<  */
< typedef struct
< {
< 
<     /** The index of the k-point for backreferencing */
<     int kidx;
< 
<     /** The k-point */
<     REAL kpt[3];
< 
<     /** The corresponding vector */
<     REAL kvec[3];
< 
<     /** The weight associated with the k-point */
<     REAL kweight;
< 
<     /** The magnitude of the k-vector */
<     REAL kmag;
< 
<     /* The orbital structure for this k-point */
<     STATE *kstate;
< 
< 
<     /* Mean min, and max wavefunction residuals for occupied space */
<     REAL meanres;
<     REAL minres;
<     REAL maxres;
< 
<     /* Total energies */
<     REAL ES;
<     REAL NUC;
<     REAL KE;
<     REAL XC;
<     REAL NL;
<     REAL II;
<     REAL TOTAL;
< 
< } KPOINT;
< 
< 
< 
< 
< /** @name CONTROL
<   @memo Main control structure
<  
<   This is a global structure declared as extern CONTROL ct
<  
<  */
< typedef struct
< {
< 
< #ifdef SMP
<     /* Number of threads to run concurrently. We always 
<      * use one thread per eigenfunction but it's inefficient 
<      * to have more threads than the number of CPU's available
<      * running concurrently. Defaults to compile time parameter 
<      * of 1 but can be overridden by setting the environment 
<      * variable QMD_NUM_THREADS to any value up to MAX_THREADS.
<      */
<     int thread_concurrency;
<     int num_threads;
< 
<     /* When running on a cluster this is the total number of nodes
<      * in the cluster.
<      */
<     int num_nodes;
< 
<     /* While this is the identity of this node */
<     int this_node;
< 
<     /* And this is the space offset of this node */
<     int node_space_offset;
< 
<     /* And this is the number of space points handled by this node */
<     int node_space_size;
< #endif
< 
<     /** Description of the run. */
<     char description[MAX_CHAR];
< 
<     /* time at which run started */
<     REAL time0;
< 
<     /** Name of the input control file. Passed as a command line argument
<      *
<      *  Example:
<      *  bash$  md in.diamond8
<      */
<     char cfile[MAX_PATH];
< 
<     /** HAndle of the output log file. Constructed from command line argument */
<     FILE *logfile;
< 
<     /** Input file name to read wavefunctions from when doing a restart */
<     char infile[MAX_PATH];
< 
<     /** Input file name to write wavefunctions to */
<     /* Output file name */
<     char outfile[MAX_PATH];
< 
<     /** File to read the pseudopotentials from */
<     /*  char pspfile[MAX_PATH]; */
< 
<     /** Initial run flag. Read from the input file. 0=initial run otherwise a restart */
<     int runflag;
< 
<     /* output z-average of states */
<     int zaverage;
< 
<     /* number of state to output */
<     int plot_state;
< 
<     /* Exchage-Correlation flag */
<     int xctype;
< 
<     /** Boundary condition flag. Read from the input file. 0=periodic, 1=cluster, 2=surface */
<     int boundaryflag;
< 
<     /* Coordinate input flag: crystal or cartesian */
<     int crd_flag;
< 
<     /* Maximum number of MD steps */
<     int max_md_steps;
< 
<     /* Maximum number of fast relax steps */
<     int max_rlx_steps;
< 
<     /* Maximum number of rmg meta loops (NEB, ARTS, etc.) */
<     int max_rmg_steps;
< 
<     /* MD steps iterator */
<     int md_steps;
< 
<     /* Maximum number of SCF steps in a MD steps */
<     int max_scf_steps;
< 
<     /* Total number of SCF steps done */
<     int total_scf_steps;
< 
<     /* SCF steps iterator */
<     int scf_steps;
< 
<     /* override occupations */
<     int override_occ;
< 
<     /* Override current ionic positions (in control file) with positions from wave file (during restart) */
<     int override_current;
< 
<     /* Override initial ionic positions (in control file) with positions from wave file (during restart) */
<     int override_initial;
< 
<     /* convergence criterion */
<     REAL thr_rms;
< 
<     /* force convergence criterion */
<     REAL thr_frc;
< 
<     /* Number of steps after which to perform checkpointing */
<     int checkpoint;
< 
<     /* Number of steps after which to output results */
<     int outcount;
< 
<     /** Sorting flag for wavefunctions. Read from input file. 0=no sort, 1=sort */
<     int sortflag;
< 
<     /** Number of states */
<     int num_states;
< 
<     /* Number of states for the opposite spin*/
<     int num_states_oppo; 
< 
<     /*Number of states for spin up and down used for initialization*/
<     int num_states_up, num_states_down;
< 
<     /** Number of unoccupied states above Fermi level */
<     int num_unocc_states;
< 
<     /** string to store repeat count occupations */
<     char occupation_str[256];
< 
<     /*string to store repeat count occupations for spin up*/
<     char occupation_str_spin_up[256];
< 
<     /*string to store repeat count occupations for spin down*/
<     char occupation_str_spin_down[256]; 
<     
< 
<     /** Number of ions */
<     int num_ions;
< 
<     /** Ion structure */
<     ION *ions;
< 
<     /** Number of species */
<     int num_species;
< 
<     /* Cutoff parameter */
<     REAL cparm;
<     REAL betacparm;
<     REAL qcparm;
< 
<     /** Total conpensating charge density */
<     REAL crho;
< 
<     /** Total charge in supercell */
<     REAL tcharge;
< 
<     /** Species structure 
<      * @see SPECIES */
<     SPECIES *sp;
< 
<     /** the fine grid size on each coarse grid cell */
<     int nxfgrid;
<     int nyfgrid;
<     int nzfgrid;
< 
<     /** Global uniform grid spacing in x */
<     REAL hxgrid;
< 
<     /** Global uniform grid spacing in y */
<     REAL hygrid;
< 
<     /** Global uniform grid spacing in z */
<     REAL hzgrid;
< 
<     /** The fine uniform grid spacing in x */
<     REAL hxxgrid;
< 
<     /** The fine uniform grid spacing in y */
<     REAL hyygrid;
< 
<     /** The fine uniform grid spacing in z */
<     REAL hzzgrid;
< 
<     /** bravais lattice type */
<     int ibrav;
< 
<     /** Lattice information */
<     REAL celldm[6];
< 
<     /* lattice vectors */
<     REAL a0[3];
<     REAL a1[3];
<     REAL a2[3];
< 
<     /** Total cell volume */
<     REAL omega;
< 
<     /* lengths of the sides of the supercell */
<     REAL xside;
<     REAL yside;
<     REAL zside;
< 
<     /* This is the max of nldim for any species cubed */
<     int max_nlpoints;
<     int max_nlfpoints;
<     int max_Qpoints;
< 
<     /** Maximum grid spacing in any coordinate direction */
<     REAL hmaxgrid;
< 
< 
<     /** Minimum grid spacing in any coordinate direction */
<     REAL hmingrid;
< 
< 
<     /** Grid anisotropy defined as the ratio of hmaxgrid to hmingrid. A value larger than 1.05 can lead to convergence problems. */
<     REAL anisotropy;
< 
< 
<     /** Volume element associated with each grid point */
<     REAL vel;
<     REAL vel_f;
< 
< 
<     /** Physical grid basis size */
<     int nbasis;
< 
< 
<     /** Density mixing parameter. Typical values range from 0.2 to 0.9, while larger values provide faster convergence as long as they are stable. */
<     REAL mix;
< 
< 
<     /* Projector mixing parameter */
<     REAL prjmix;
< 
<     /* Global uniform grid corner */
<     REAL xcstart;
<     REAL ycstart;
<     REAL zcstart;
< 
< 
<     /* Hartree potential offset from wavefunction grid */
<     int vh_xoffset;
<     int vh_yoffset;
<     int vh_zoffset;
< 
< 
<     /* Hartree potential grid sizes */
<     int vh_nxgrid;
<     int vh_nygrid;
<     int vh_nzgrid;
< 
< 
<     /* Hartree potential grid sizes per domain */
<     int vh_pxgrid;
<     int vh_pygrid;
<     int vh_pzgrid;
< 
< 
<     /* Total points in hartree potential per domain */
<     int vh_pbasis;
< 
< 
<     /* Wavefunction grid sizes */
<     int psi_nxgrid;
<     int psi_fnxgrid;
<     int psi_nygrid;
<     int psi_fnygrid;
<     int psi_nzgrid;
<     int psi_fnzgrid;
< 
<     /* Total points for wavefunctions */
<     int psi_nbasis;
<     int psi_fnbasis;
< 
<     /* Decoupled hartree potential */
<     REAL *vh_ext;
< 
< 
<     /* Mean min, and max wavefunction residuals for occupied space */
<     REAL meanres;
<     REAL minres;
<     REAL maxres;
< 
<     /* total ionic charge */
<     REAL ionic_charge;
< 
<     /* Variable occupation stuff */
<     REAL nel;
< 
<     int occ_flag;
< 
<     REAL occ_width;
< 
<     REAL occ_mix;
< 
<     /** total background smearing charge -- for charged supercells */
<     REAL background_charge;
< 
< 
<     /** Multigrid parameters for the eigenvalue solver */
<     MG_PARM eig_parm;
< 
<     /** Multigrid parameters for the poisson solver */
<     MG_PARM poi_parm;
< 
< 
<     /** Nose paramters */
<     FINITE_T_PARM nose;
< 
<     /* force pointer array */
<     int fpt[4];
< 
<     /* temperature control */
<     int tcontrol;
< 
<     /* md integrate level */
<     int mdorder;
< 
<     /* movie flags */
<     int rmvmovie, chmovie, xbsmovie;
< 
<     /* Milliken population flags. */
<     int domilliken;
<     int milliken;
< 
<     /* Diagonalization flag and period */
<     int initdiag;
<     int diag;
<     int end_diag;
< 
<     /* How many steps between writeout of eigenvalues*/
<     int write_eigvals_period;
< 
<     /* Diagonalizations during the md step */
<     int mddiag1;
<     int mddiag2;
< 
<     /** Force flag. 0=don't compute forces, 1=compute forces */
<     int forceflag;
< 
<     /* Whether to write full memory usage report at the end of calculation */
<     int write_memory_report;
< 
<     /** Ionic motion timestep */
<     REAL iondt;
< 
< 
<     /** Ionic motion energy */
<     REAL ionke;
< 
< 
<     /* Total energies */
<     REAL ES;
<     REAL NUC;
<     REAL KE;
<     REAL XC;
<     REAL NL;
<     REAL II;
<     REAL TOTAL;
< 
<     /* fermi energy */
<     REAL efermi;
< 
<     /** Total number of k-points being used in the calculation */
<     int num_kpts;
< 
< 
<     /** K-point control structure */
<     KPOINT *kp;
< 
<     /** Throttles data transfer rates when writing wavefunctions to disk
<      *
<      * On clusters with NFS mounted filesystems having all nodes
<      * dump there data at the same time can cause network congestion
<      * and hangups so wait_flag can be set in the input file to throttle
<      * the total bandwidth being written. */
<     int wait_flag;
< 
<     /** The maximum number of projectors for any species */
<     int max_nl;
< 
<     /*Maximum value of nldim for any species */
<     int max_nldim;
< 
<     /*This keeps track whether ct.fftw_wisdom_setup was setup or not so that
<      * we know whether to release wisdom memory at the end or not*/
<     int fftw_wisdom_setup;
< 
< 
<     /*Interpolation flags */
<     int interp_flag;
< 
<     /*Order of B-spline */
<     int interp_order;
< 
<     /*Order of trade_image used in interpolation */
<     int interp_trade;
< 
<     /* the external electric field */
<     REAL e_field;
< 
<     REAL x_field_0;
< 
<     REAL y_field_0;
< 
<     REAL z_field_0;
< 
< 
< } CONTROL;
< 
< 
< #ifdef SMP
< 
< /* Thread control structures */
< typedef struct
< {
< 
<     /* Thread ID number */
<     int tid;
< 
<     /* These volatiles are used as synchronization variables for the threads */
<     volatile int start;
< 
<     /* With the complex option this lets the threads know which k-point is
<      * currently being worked on in ortho and subdiag. */
<     int kidx;
< 
<     /* Pointer to state array used by each thread */
<     STATE *my_states;
< 
<     /* Local variable -- summed to obtain total charge for all orbitals */
<     REAL tcharge;
< 
<     /* Spacial offset for the thread */
<     int offset;
< 
<     /* Points to base of distributed storage array for this thread */
<     REAL *base_mem;
< 
<     /* Points to base of distributed scratch array for this thread */
<     REAL *scratch1;
< 
<     /* Number of points per wavefunction in the distributed storage array */
<     int numpt;
< 
<     /* leading dimension of the distributed wave function storage array */
<     int lda;
< 
<     /* Local copies of eigenvalues and occupations for this thread */
<     REAL *eigs;
<     REAL *occs;
< 
<     /* Force contributions computed by this thread */
<     REAL force[MAX_IONS][3];
< 
<     /* Pointer to dynamically allocated arrays of size ct.num_states*ct.num_states */
<     /* that is required in ortho. Each thread has it's own copy */
<     REAL *darr;
<     REAL *barr;
< 
< 
<     /* The same array as referenced by darr but this copy is 
<      *allocated in the main program rather than in one of the threads.
<      */
<     REAL *farr;
< 
< 
<     REAL *rho;
<     REAL *rhocore;
<     REAL *vtot;
<     REAL *vnuc;
< 
<     /* Pointers to the non-local potential index list 
<      *and to the projectors themselves */
<     int *nlindex;
<     REAL *projectors;
< 
< 
< } SCF_THREAD_CONTROL;
< #endif
< 
< 
< 
< /* Extern declaration for the main control structure */
< extern CONTROL ct;
< 
< 
< /* Extern declaration for the processor control structure */
< extern PE_CONTROL pct; 
< 
< 
< /* Extern declarations for thread control structures */
< #ifdef SMP
< extern SCF_THREAD_CONTROL thread_control[];
< #endif
< 
1375,1978d78
< /* Function prototypes */
< void app_4del2 (S0_GRID *f, P0_GRID *work);
< REAL app_del2c (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                 REAL gridhx, REAL gridhy, REAL gridhz);
< void app6_del2 (REAL *rho, P0_GRID * work);
< void app6_del2f (REAL *rho, FP0_GRID * work);
< void app_smooth (S0_GRID *f, S0_GRID *work, REAL sfac);
< /*void app_smooth1(FS0_GRID *f, FS0_GRID *work);*/
< void app_cir_sixth (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_ortho (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_bcc (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_fcc (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_hex (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< REAL app_cilr (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_bcc (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_fcc (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_hex (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_ortho (REAL *a, REAL *b, REAL *c, int dimx, int dimy,
<                      int dimz, REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil (REAL *a, REAL *b, int dimx, int dimy, int dimz, REAL gridhx,
<               REAL gridhy, REAL gridhz);
< REAL app_cil_sixth (REAL *psi, REAL *b, int dimx, int dimy, int dimz,
<                     REAL gridhx, REAL gridhy, REAL gridhz);
< void app_grad (REAL  * rho, P0_GRID * wx, P0_GRID * wy, P0_GRID * wz);
< void app_gradf (REAL * rho, FP0_GRID * wx, FP0_GRID * wy, FP0_GRID * wz);
< void constrain(ION *iptr);
< void corlyp (REAL *dp, REAL *dm, REAL *dp1, REAL *dm1, REAL *dp2, REAL *dm2, REAL *ec,
<              REAL *vcp0, REAL *vcm0, int *ndm);
< void cross_product (REAL *a, REAL *b, REAL *c);
< void destroy_fftw_wisdom (void);
< void eval_residual (REAL *mat, REAL *f_mat, int dimx, int dimy, int dimz,
<                     REAL gridhx, REAL gridhy, REAL gridhz, REAL *res);
< void solv_pois (REAL *vmat, REAL *fmat, REAL *work,
<                 int dimx, int dimy, int dimz, REAL gridhx,
<                 REAL gridhy, REAL gridhz, REAL step);
< REAL fill (STATE *states, REAL width, REAL nel, REAL mix,
<            int num_st, int occ_flag);
< REAL fill_spin(STATE *states_up, REAL * eigval_dn, REAL width, REAL nel, REAL mix, int num_st, int occ_flag);
< 
< void find_phase (int nldim, REAL *nlcdrs, REAL *phase_sin,
<                  REAL *phase_cos);
< void finish_release_mem(STATE *states);
< void genvpsi (REAL *psi, REAL *twovpsi, REAL *pvtot, REAL *pvnl,
<               REAL *kd, REAL kmag, int dimx, int dimy, int dimz);
< void get_nlop (void);
< void get_weight (void);
< void get_phase (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_nlop_smp (int tid);
< void get_eig (STATE *states, P0_GRID *vxc, P0_GRID *vh, P0_GRID *vnuc);
< char *get_num (char *str);
< void get_te (REAL *rho, REAL *rhocore, REAL *rhoc, REAL *vh, REAL *vxc,
<              STATE *states);
< void get_te_spin (REAL *rho, REAL *rho_oppo, REAL *rhocore, REAL *rhoc, REAL *vh, REAL *vxc,
<              STATE *states);
< 
< void get_vxc (REAL *rho, REAL *rhocore, REAL *vxc);
< void get_vxc_spin (REAL *rho, REAL * rho_oppo, REAL *rhocore, REAL *vxc);
< 
< 
< void get_zdens (STATE *states, int state, REAL *zvec);
< void xclda_pz81 (REAL *rho, REAL *vxc);
< void exclda_pz81 (REAL *rho, REAL *exc);
< 
< /* new lda function incorporating both  1981 and 1994 monte carlo data */
< void xclda(REAL *rho, REAL *vxc, REAL *exc);
< void slater(REAL rs, REAL *ex, REAL *vx);
< void pz(REAL rs, int iflag, REAL *ec, REAL *vc); 
< 
< /* lsda exchange correlation functional */
< void xclsda_spin(REAL *rho, REAL *rho_oppo, REAL *vxc, REAL *exc);
< void slater_spin(REAL arhox, REAL zeta, REAL *ex, REAL *vx, REAL *vx_oppo);
< void pz_spin(REAL rs, REAL zeta, REAL *ec, REAL *vc, REAL *vc_oppo);
< void pz_polarized(REAL rs, REAL *ec, REAL *vc);
< void pw_spin (REAL rs, REAL zeta, REAL *ec, REAL *vcup, REAL *vcdw);
< void pw (REAL rs, int iflag, REAL *ec, REAL *vc) ;
< 
< 
< double mu_pz (double rho);
< double e_pz (double rho);
< void xcgga (REAL *rho, REAL *vxc, REAL *exc, int flag);
< void xcgga_spin (REAL *rho, REAL *rho_oppo, REAL *vxc, REAL *exc, int flag);
< 
< 
< /* exchange correlation functional for PBE */
< 
< void gcxcpbe_spin(REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< void pbex (REAL rho, REAL grho, int iflag, REAL *sx, REAL *v1x, REAL *v2x);
< void pbec_spin (REAL rho, REAL zeta, REAL grho, int iflag, REAL *sc, REAL *v1cup, REAL *v1cdw, REAL *v2c);
< 
< void gcxcpbe (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< 
< void pbec (REAL rho, REAL grad, int iflag, REAL *sc, REAL *v1c, REAL *v2c);
< 
< 
< 
< /* becke88 exchange and perdew86 correlation */
< 
< void becke88 ( REAL rho, REAL grho, REAL *sx, REAL *v1x, REAL *v2x );
< void perdew86 ( REAL rho, REAL grho, REAL *sc, REAL *v1c, REAL *v2c );
< void gcxbcp (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< void perdew86_spin ( REAL rho, REAL zeta, REAL grho, REAL *sc, REAL *v1cup, REAL *v1cdw, REAL *v2c );
< void becke88_spin ( REAL rho, REAL grho, REAL *sx, REAL *v1x, REAL *v2x );
< void gcxbcp_spin (REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< 
< 
< /* PW91 exchange correlation */
< 
< void ggax(REAL rho, REAL grho, REAL *sx, REAL *v1x, REAL *v2x);
< void ggac (REAL rho, REAL grho, REAL *sc, REAL *v1c, REAL *v2c);
< void ggac_spin (REAL rho, REAL zeta, REAL grho, REAL *sc, REAL *v1cup, REAL *v1cdw, REAL *v2c);
< void gcxcpw91 (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< void gcxcpw91_spin(REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< 
< 
< /* BLYP exchange correlation */
< 
< void lyp ( REAL rs, REAL *ec, REAL *vc );
< void glyp ( REAL rho, REAL grho, REAL *sc, REAL *v1c, REAL *v2c );
< void lsd_lyp ( REAL rho, REAL zeta, REAL * elyp, REAL * valyp, REAL * vblyp );
< void lsd_glyp ( REAL rhoa, REAL rhob, REAL grhoaa, REAL grhoab2, REAL grhobb, REAL *sc, REAL *v1ca, REAL *v2ca, REAL *v1cb, REAL *v2cb, REAL *v2cab );
< void gcxcblyp (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< void gcxcblyp_spin (REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad_updw2, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< 
< 
< 
< void gram (KPOINT *kpoint, REAL h, int numst, int maxst, int numpt,
<            int maxpt);
< int get_input (FILE *fh, char *id, void *dest, unsigned int flag, char *def);
< REAL get_ke (STATE *sp, int tid);
< void get_vh (REAL *rho, REAL *rhoc, REAL *vh, int cycles, int maxlevel);
< char *get_symbol (int atomic_number);
< void global_sums (REAL *vect, int *length);
< void global_sums_spin (REAL *vect, int *length);
< void init (REAL *vh, REAL *rho, REAL *rhocore, REAL *rhoc, STATE *states,
<            REAL *vnuc, REAL *vxc);
< void init_spin (REAL *vh, REAL *rho, REAL *rho_oppo, REAL *rhocore, REAL *rhoc, STATE *states,
<            REAL *vnuc, REAL *vxc);
< void init_derweight (void);
< void init_derweight_s (SPECIES *sp, fftw_complex *rtptr_x,
<                        fftw_complex *rtptr_y, fftw_complex *rtptr_z, int ip,
<                        fftwnd_plan p1);
< void init_derweight_p (SPECIES *sp, fftw_complex *rtptr_x,
<                        fftw_complex *rtptr_y, fftw_complex *rtptr_z, int ip,
<                        fftwnd_plan p1);
< void init_derweight_d (SPECIES *sp, fftw_complex *rtptr_x,
<                        fftw_complex *rtptr_y, fftw_complex *rtptr_z, int ip,
<                        fftwnd_plan p1);
< void init_fftw_wisdom (void);
< void init_kbr (void);
< void init_IO ( int argc, char **argv );
< void init_pe (void);
< void init_img_topo ( int dimensionality );
< void init_pegrid (void);
< STATE *init_states (void);
< STATE *init_states_spin(void);
< void init_weight (void);
< void init_weight_s (SPECIES *sp, fftw_complex *rtptr, int ip,
<                     fftwnd_plan p1);
< void init_weight_p (SPECIES *sp, fftw_complex *rtptr, int ip,
<                     fftwnd_plan p1);
< void init_weight_d (SPECIES *sp, fftw_complex *rtptr, int ip,
<                     fftwnd_plan p1);
< void init_wf (STATE *states);
< void init_nuc (REAL *vnuc, REAL *rhoc, REAL *rhocore);
< void init_pos (void);
< void init_sym (void);
< void symmetrize_rho (FP0_GRID *rho);
< void symforce (void);
< void cforce (P0_GRID *rho, P0_GRID *vh);
< void mgrid_solv (REAL *v_mat, REAL *f_mat, REAL *work,
<                  int dimx, int dimy, int dimz, REAL gridhx, REAL gridhy,
<                  REAL gridhz, int level, int *nb_ids, int max_levels,
<                  int *pre_cyc, int *post_cyc, int mu_cyc, REAL step);
< void rmg_timings (int what, REAL time, int tid);
< REAL minimage (ION *ip1, ION *ip2, REAL *xtal_r);
< REAL my_crtc (void);
< /* Local function prototypes */
< FILE *open_xbs_movie (char *filename);
< int open_wave_file (char *filename);
< void xbsmovie (FILE *movie);
< void ortho_half (STATE *states);
< void ortho_bcc (STATE *states);
< void output_eigenvalues( STATE *states, int ikbs, int iscf );
< void pe2xyz (int pe, int *x, int *y, int *z);
< void pack_ptos (REAL *sg, REAL *pg, int dimx, int dimy, int dimz);
< void pack_stop (REAL *sg, REAL *pg, int dimx, int dimy, int dimz);
< void pack_stop_axpy (REAL *sg, REAL *pg, REAL alpha, int dimx, int dimy,
<                      int dimz);
< void pack_ptos_trade (REAL *sg, REAL *pg, int dimx, int dimy, int dimz);
< void pack_vhstod (REAL *s, REAL *d, int dimx, int dimy, int dimz);
< void pack_vhdtos (REAL *s, REAL *d, int dimx, int dimy, int dimz);
< double radint (double *f, double *r, int n, double al);
< REAL radint1 (REAL *f, REAL *r, REAL *dr_di, int n);
< void radiff (double *f, double *df, double *r, int n, double al);
< void ra2diff (double *f, double *df, double *r, int n, double al);
< void ranv (void);
< void read_control(void);
< void write_pdb (void);
< int read_atom_line(char *species, REAL *crds, int *movable, FILE *fhand, char *tbuf, int index);
< int assign_species (CONTROL * c, char *buf);
< void read_data (char *name, REAL *vh, REAL *rho, REAL *vxc,
<                 STATE *states);
< void read_data_spin (char *name, REAL *vh, REAL *rho, REAL *rho_oppo, REAL *vxc,
<                 STATE *states);
< 
< void read_pseudo (void);
< REAL real_sum_all (REAL x);
< REAL real_sum_all_spin (REAL x);
< REAL real_min_all (REAL x);
< 
< 
< void reset_timers (void);
< /*void scf(STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<            REAL *rho, REAL *rhocore, REAL *rhoc, int *CONVERGENCE);*/
< void sortpsi (STATE *states);
< /*void subdiag(STATE *states, REAL *vh, REAL *vnuc, REAL *vxc);*/
< void trade_images (REAL *mat, int dimx, int dimy, int dimz, int *nb_ids);
< void trade_imagesx (REAL *f, REAL *w, int dimx, int dimy, int dimz,
<                     int images);
< void set_bc (REAL *mat, int dimx, int dimy, int dimz, int images, REAL val);
< void set_bcx (REAL *mat, int dimx, int dimy, int dimz, int images, REAL val);
< void getpoi_bc (REAL *rho, REAL *vh_bc, int dimx, int dimy, int dimz);
< /*void trade_images2(S0_GRID *f, SS0_GRID *w);
< void trade_images2f(FS0_GRID *f, FSS0_GRID *w);
< void trade_images3(S0_GRID *f, S30_GRID *w);
< void trade_images5(S0_GRID *f, S50_GRID *w);*/
< void vol_rho (P0_GRID *rho, int step);
< void vol_wf (STATE *states, int state, int step);
< void write_avgd (REAL *rho);
< void write_avgv (REAL *vh, REAL *vnuc);
< void write_zstates (STATE *states);
< void write_data (char *name, REAL *vh, REAL *rho, REAL *vxc,
<                  STATE *states);
< 
< void write_data_spin (char *name, REAL *vh, REAL *rho, REAL *rho_oppo, REAL *vxc,
<                  STATE *states);
< void write_header (void);
< void write_occ (STATE *states);
< void write_force (void);
< void write_timings (void);
< void wvfn_residual(STATE *states);
< REAL rand0 (long *idum);
< 
< void mg_restrict (REAL *full, REAL *half, int dimx, int dimy, int dimz);
< void mg_prolong (REAL *full, REAL *half, int dimx, int dimy, int dimz);
< void gather_psi (REAL *tmp_psiR, REAL *tmp_psiI, STATE *sp, int tid);
< void scatter_psi (REAL *tmp_psiR, REAL *tmp_psiI, STATE *sp, int tid);
< void get_milliken (STATE *states);
< 
< #ifdef SMP
< void create_threads (STATE *states);
< void start_threads (int action);
< void wait_for_threads (void);
< void thread_spinlock (int *lockptr);
< void *thread_scheduler (void *);
< void thread_dispatch (SCF_THREAD_CONTROL *s, int job);
< void ortho1_smp (SCF_THREAD_CONTROL *s);
< void ortho2_smp (SCF_THREAD_CONTROL *s);
< void get_rho_smp (SCF_THREAD_CONTROL *s);
< void sort_psi_smp (SCF_THREAD_CONTROL *s);
< void subdiag1_smp (SCF_THREAD_CONTROL *s);
< void subdiag2_smp (SCF_THREAD_CONTROL *s);
< #endif
< 
< void bandstructure( STATE *states, REAL *vxc, REAL *vh, REAL *vnuc );
< void output_wave( STATE *states, int kpt, int fhand );
< 
< void QMD_sem_init (QMD_sem_t *sem);
< void QMD_sem_destroy (QMD_sem_t *sem);
< void QMD_sem_wait (QMD_sem_t *sem);
< void QMD_sem_post (QMD_sem_t *sem);
< 
< /* Blas wrappers */
< void QMD_saxpy (int n, REAL alpha, REAL *x, int incx, REAL *y, int incy);
< void QMD_sscal (int n, REAL alpha, REAL *x, int incx);
< void QMD_scopy (int n, REAL *x, int incx, REAL *y, int incy);
< REAL QMD_sdot (int n, REAL *x, int incx, REAL *y, int incy);
< 
< 
< 
< int get_index (ION *iptr, int *Aix, int *Aiy, int *Aiz,
<                int *ilow, int *ihi, int *jlow, int *jhi, int *klow,
<                int *khi, int cdim, int pxgrid, int pygrid, int pzgrid,
<                int nxgrid, int nygrid, int nzgrid,
<                REAL *lxcstart, REAL *lycstart, REAL *lzcstart);
< 
< REAL linint (REAL *y, REAL rv, REAL invdr);
< void my_barrier (void);
< 
< 
< #ifdef UNICOS_T3E
< #define exit globalexit
< #endif
< 
< /* Conversion between crystal and cartesian coordinate prototypes */
< void latgen (int *ibrav, REAL *celldm, REAL *A0I, REAL *A1I, REAL *A2I,
<              REAL *OMEGAI, int *flag);
< void recips (void);
< void to_cartesian (REAL crystal[], REAL cartesian[]);
< void to_crystal (REAL crystal[], REAL cartesian[]);
< REAL metric (REAL *crystal);
< 
< /* Md run types */
< void quench (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc, REAL *rho,
<              REAL *rhocore, REAL *rhoc);
< void quench_spin (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc, REAL *rho,
<              REAL *rho_oppo, REAL *rhocore, REAL *rhoc);
< void fastrlx (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<               REAL *rho, REAL *rhocore, REAL *rhoc);
< void fastrlx_spin (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<               REAL *rho, REAL *rho_oppo, REAL *rhocore, REAL *rhoc);
< void neb_relax (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<               REAL *rho, REAL *rhocore, REAL *rhoc);
< void cdfastrlx (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<                 REAL *rho, REAL *rhocore, REAL *rhoc);
< void moldyn (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<              REAL *rho, REAL *rhoc, REAL *rhocore);
< void dx (STATE *states, P0_GRID *vxc, P0_GRID *vh, P0_GRID *vnuc,
<          P0_GRID *rho, P0_GRID *rhoc);
< void psidx (STATE *states, P0_GRID *vxc, P0_GRID *vh, P0_GRID *vnuc,
<             P0_GRID *rho, P0_GRID *rhoc);
< void cholesky (REAL *a, int n);
< 
< 
< /*the function for softpseudopotential*/
< void aainit (int lli, int mix, int lx, int mx, int nlx, double ap[][9][9],
<              int lpx[][9], int lpl[][9][9]);
< REAL app_cil1 (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_bcc (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_fcc (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_hex (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_ortho (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                      REAL gridhx, REAL gridhy, REAL gridhz);
< void app_nl_psi (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int flag, int kidx, int tid);
< void app_nl_eig (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int flag, int kidx, int tid);
< void app_ns_psi (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int kidx, int tid);
< void app_ns_eig (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int kidx, int tid);
< void get_ddd (REAL *veff);
< void get_nlop_d (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_nlop_p (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_nlop_s (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_QI (void);
< void get_qqq (void);
< void get_rho (STATE * states, REAL * rho, REAL * rhocore);
< void init_psp (void);
< void init_qfunct (void);
< void mg_eig_state (STATE *sp, int tid, REAL *vtot_psi);
< void ortho_full (STATE *states);
< void ortho (STATE *states, int kpt);
< REAL qval (int ih, int jh, REAL r, REAL invdr, REAL *ptpr, int *nhtol,
<            int *nhtom, int *indv, REAL *ylm, REAL ap[][9][9], int lpx[][9],
<            int lpl[][9][9], SPECIES *sp);
< void scf (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<           REAL *rho, REAL *rhocore, REAL *rhoc, int *CONVERGENCE);
< void scf_spin (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<           REAL *rho,REAL *rho_oppo, REAL *rhocore, REAL *rhoc, int *CONVERGENCE);
< 
< #if GAMMA_PT
< void subdiag_gamma (STATE *states, REAL *vh, REAL *vnuc, REAL *vxc);
< #else
< void subdiag_nongamma (STATE * states, REAL * vh, REAL * vnuc, REAL * vxc);
< #endif
< 
< void ylmr2 (double *r, double *ylm);
< REAL gcutoff (REAL g1, REAL gcut, REAL width);
< void rft1 (REAL cparm, REAL *f, REAL *r, REAL *ffil, REAL *rab,
<            int rg_points, int lval, REAL dr, REAL width, int lrg_points);
< void norm_psi1 (STATE *sp, int istate, int kpt);
< void ortho_get_coeff (STATE * sp1, STATE * sp2, int ist1, int ist2, int kidx, REAL *cR, REAL *cI);
< void update_waves (STATE * sp1, STATE * sp2, int ist1, int ist2, int kidx, REAL cR, REAL cI);
< REAL get_QnmL (int idx, int ltot, REAL r, SPECIES *sp);
< 
< /*force for softpseudopotential*/
< void force (REAL *rho, REAL *rhoc, REAL *vh, REAL *vxc, REAL *vnuc,
<             STATE *states);
< 
< void force_spin (REAL *rho, REAL *rho_oppo, REAL *rhoc, REAL *vh, REAL *vxc, REAL *vnuc,
<             STATE *states);
< 
< void iiforce (void);
< void lforce (REAL *rho, REAL *vh);
< void nlforce1 (REAL *veff);
< void get_gamma (REAL *gammaR, ION *iptr, int nh);
< void partial_gamma (int ion, REAL *par_gammaR, REAL *par_omegaR, ION *iptr,
<                     int nh, REAL *newsintR_x, REAL *newsintR_y,
<                     REAL *newsintR_z, REAL *newsintI_x, REAL *newsintI_y,
<                     REAL *newsintI_z);
< void partial_betaxpsi (int ion, fftwnd_plan p2, REAL *newsintR_x,
<                        REAL *newsintR_y, REAL *newsintR_z,
<                        REAL *newsintI_x, REAL *newsintI_y,
<                        REAL *newsintI_z, ION *iptr);
< void nlforce1_par_Q (REAL *veff, REAL *gamma, int ion, ION *iptr, int nh,
<                      REAL *forces);
< void nlforce1_par_gamma (REAL *par_gamma, int ion, int nh);
< void nlforce1_par_omega (REAL *par_omega, int ion, ION *iptr, int nh);
< void partial_QI (int ion, REAL *QI_R, ION *iptr);
< void qval_R (int ih, int jh, REAL r, REAL *x, REAL *qlig, REAL *drqlig,
<              REAL invdr, int *nhtol, int *nhtom, int *indv, REAL *ylm,
<              REAL *ylm_x, REAL *ylm_y, REAL *ylm_z, REAL ap[][9][9],
<              int lpx[][9], int lpl[][9][9], REAL *Q_x, REAL *Q_y,
<              REAL *Q_z, SPECIES *sp);
< void ylmr2_x (double *r, double *ylm_x);
< void ylmr2_y (double *r, double *ylm_y);
< void ylmr2_z (double *r, double *ylm_z);
< void nlccforce (REAL *rho, REAL *vxc);
< REAL get_ve_nl (STATE *sta, int istate);
< void pack_rho_ctof (REAL *rhoc, REAL *rhof);
< void bspline_interp_full (REAL *rho, REAL *rho_f);
< void get_vtot_psi (REAL *vtot_psi, REAL *vtot);
< void betaxpsi (STATE *states);
< void betaxpsi1 (STATE *states, int kpt);
< void assign_weight (SPECIES *sp, int ion, fftw_complex *beptr,
<                     REAL *rtptr);
< void assign_weight2 (int nldim, int ion, REAL *beptr, REAL *rtptr);
< void pack_gftoc (SPECIES *sp, fftw_complex *gwptr, fftw_complex *gbptr);
< void debug_write_rho_z (REAL *rhoz);
< void print_density_z_direction (int grid_x, int grid_y, REAL *density,
<                                 int px0_grid, int py0_grid, int pz0_grid,
<                                 REAL zside);
< void get_derweight (int ion, REAL *beta_x, REAL *beta_y, REAL *beta_z,
<                     ION *iptr, fftwnd_plan p2);
< void partial_beta_fdiff (fftw_complex *beptr, int nldim, REAL *beta_x,
<                          REAL *beta_y, REAL *beta_z);
< 
< void mulliken (STATE *states);
< REAL ylm(int l, REAL *r);
< int listlen (FILE * fh, char *id);
< int del_space (FILE * fh, int *tchr, int isdata);
< void norm_psi1_parallel (STATE * sp, int istate, int kidx);
< void print_matrix(double *b, int n, int ldb);
< void sl_init(int *ictxt, int size);
< void sl_exit(int ictxt);
< void set_desca(int *desca, int *ictxt, int *size);
< void distribute_mat(int *desca, double *bigmat, double *dismat, int *size);
< void matinit(int *desca, double *dismat, double *globmat, int size);
< void print_distribute_mat(double *dismat, int *desca, int size);
< void init_efield (REAL * vnuc);
< void pulay(int step, int N, double *xm, double *fm, int NsavedSteps, int preconditioning);
< 
< 
< /* Some stuff for timing and performance measurements */
< #define TOTAL_TIME (0)
< #define ORTHO_TIME (1)
< //#define NL_TIME (2)
< //#define NS_TIME (3)
< #define EIG_TIME (4)
< #define IMAGE_TIME (5)
< //#define APPCIL_TIME (6)
< //#define APPCIR_TIME (7)
< #define RESTRICT_TIME (8)
< #define EXPAND_TIME (9)
< #define PACK_TIME (10)
< #define INIT_TIME (11)
< #define HARTREE_TIME (12)
< #define DIAG_TIME (13)
< #define LFORCE_TIME (14)
< #define NLFORCE_TIME (15)
< #define APPGRAD_TIME (16)
< #define GATHER_TIME (17)
< #define MG_EIGTIME (18)
< #define INTERPOLATION_TIME (19)
< #define RHO_TIME (20)
< #define FORCE_TIME (21)
< #define SCF_TIME (22)
< //#define MD_LOOP (23)
< #define NLCCFORCE_TIME (24)
< #define IIFORCE_TIME (25)
< #define MG_EIG_NLS_TIME (26)
< #define MG_EIG_APPCIL_TIME (27)
< #define MG_EIG_APPCIR_TIME (28)
< #define MG_EIG_TRADE_TIME (29)
< #define DIAG_NL_TIME (30)
< #define DIAG_APPCIL_TIME (31)
< #define DIAG_APPCIR_TIME (32)
< #define GET_TE_XC_TIME (33)
< #define GET_TE_II_TIME (34)
< #define GET_TE_TIME (35)
< #define SCF_XC_TIME (36)
< #define INTERP_SETUP_TIME (37)
< #define INTERP_EVAL_TIME (38)
< #define DIAG_SUBDIAG1_TIME (39)
< #define DIAG_MATRIX_TIME (40)
< #define DIAG_WAVEUP_TIME (41)
< #define DIAG_SUBDIAG1_LOOP_TIME (42)
< #define DIAG_APP_A (43)
< #define DIAG_APP_S (44)
< #define DIAG_APP_B (45)
< #define DIAG_DGEMM (46)
< #define DIAG_GENVPSI_TIME (47)
< #define DIAG_GLOB_SUMS (48)
< #define DIAG_BETAXPSI (49)
< #define ALLOC_TIME (50)
< #define ORTHO_BETAXPSI (51)
< #define ORTHO_NORM_PSI (52)
< #define ORTHO_NEW_PSI (53)
< #define ORTHO_GET_COEFF (54)
< #define ORTHO_GLOB_SUM (55)
< #define ORTHO_UPDATE_WAVES (56)
< #define DIAG_APPCIR_TIME2 (57)
< #define MG_EIG_GENVPSI_TIME (58)
< #define MG_EIG_EIGVALUE_TIME (59)
< #define MG_EIG_APPSMOOTH_TIME (60)
< #define MG_EIG_MGRIDSOLV_TIME (61)
< #define MG_EIG_PACK_TIME (62)
< #define DIAG_NLS_TIME (63)
< #define PREINIT_TIME (64)
< #define FINISH_TIME (65)
< #define DIAG_SCALAPACK_INIT (66)
< #define DIAG_DISTMAT (67)
< #define REAL_SUM_ALL_TIME (68)
< #define GLOBAL_SUMS_TIME (69)
< #define DIAG_BCAST_EIGS (70)
< #define READ_PSEUDO_TIME 71
< #define READ_CONTROL_TIME 72
< 
< #define LAST_TIME (80)
< 
< 
< /* Occupation flags */
< #define OCC_NONE 0
< #define OCC_FD 1
< #define OCC_GS 2
< #define OCC_EF 3
< 
< 
< /* SMP directives for the threads */
< #define     SMP_EIG       1
< #define     SMP_ORTHO1    2
< #define     SMP_ORTHO2    3
< #define     SMP_GET_RHO   4
< #define     SMP_SORT_PSI  5
< #define     SMP_SKIP      6
< #define     SMP_DIAG1     7
< #define     SMP_DIAG2     8
< #define     SMP_NLFORCE   9
< #define     SMP_GETNLOP  10
< 
< 
< /* Crystal lattice types */
< /** Simple cubic lattice type.
<  *  @doc Set input file value = 1 */
< #define CUBIC_PRIMITIVE 	1
< 
< /** Face centered cubic lattice type. 
<  *  @doc Set input file value = 2 */
< #define CUBIC_FC		2
< 
< /** Bodycentered cubic lattice type. 
<  *  @doc Set input file value = 3 */
< #define CUBIC_BC		3
< 
< /** Hexagonal lattice type. 
<  *  @doc Set input file value = 4 */
< #define HEXAGONAL		4
< 
< #define TRIGONAL_PRIMITIVE	5
< #define TETRAGONAL_PRIMITIVE	6
< #define TETRAGONAL_BC           7
< 
< /** Orthorhombic lattice type. 
<  *  @doc Set input file value = 8 */
< #define ORTHORHOMBIC_PRIMITIVE  8
< 
< #define ORTHORHOMBIC_BASE_CENTRED 9
< #define ORTHORHOMBIC_BC         10
< #define ORTHORHOMBIC_FC 11
< #define MONOCLINIC_PRIMITIVE 12
< #define MONOCLINIC_BASE_CENTRED 13
< #define TRICLINIC_PRIMITIVE 14
< 
< /* The real or imaginary part of a wavefunction */
< #define PSI_REAL     0
< #define PSI_IMAG     1
< 
< 
< 
< 
< 
< 
1987a88,93
> 
> /* Custom types used in the code*/
> #include "typedefs.h"
> 
> /*Prototypes for function calls*/
> #include "prototypes.h"
Only in ./Headers: make_conf.h
Only in ../ultrasoft/./Headers: my_mpi.h
diff ./Headers/my_scalapack.h ../ultrasoft/./Headers/my_scalapack.h
2c2
<  **    $Id: my_scalapack.h 1004 2008-08-09 18:37:21Z froze $    **
---
>  **    $Id: my_scalapack.h 1220 2011-01-27 23:59:08Z miro $    **
34c34
< #endif
---
> #else
36c36
< #if  ( LINUX ||  IRIX || XT3 )
---
> #ifdef  LINUX
54a55
> #endif
diff ./Headers/params.h ../ultrasoft/./Headers/params.h
2c2
<  **    $Id: params.h 1062 2009-08-11 20:13:24Z froze $    **
---
>  **    $Id: params.h 1161 2010-10-26 23:18:51Z froze $    **
177,185d176
< 
< 
< #ifdef SMP
< #  define         PHYS_PES        1
< #else
< #  define         PHYS_PES        (NPES)
< #endif
< 
< 
Only in ../ultrasoft/./Headers: prototypes.h
Only in ../ultrasoft/./Headers: recips.h
Only in ../ultrasoft/./Headers: salloc.h
Common subdirectories: ./Headers/.svn and ../ultrasoft/./Headers/.svn
Only in ../ultrasoft/./Headers: typedefs.h
Only in ../ultrasoft/./Headers: version.h
2c2
<  **    $Id: main.h 1199 2011-01-21 20:58:27Z yanli $    **
---
>  **    $Id: main.h 1241 2011-02-01 23:45:44Z miro $    **
57d56
< 
68a68,70
> /* include scalapack wrapper */
> #include "my_scalapack.h"
> 
72,1369d73
< #ifdef SMP
< #  include <pthread.h>
< #  include <semaphore.h>
< 
< typedef struct
< {
<     volatile int count;
<     pthread_mutex_t mutex;
<     pthread_cond_t cond;
< } QMD_thread_barrier_struct;
< 
< void QMD_thread_barrier (QMD_thread_barrier_struct * bs);
< 
< #  if (AIX || LINUX || XT3)
< typedef struct
< {
<     pthread_mutex_t lock;
<     pthread_cond_t cond;
<     int count;
< } QMD_sem_t;
< #  else
< typedef struct
< {
<     sem_t sem;
< } QMD_sem_t;
< #  endif
< #endif
< 
< 
< #if MPI
< typedef struct
< {
<     int count;
< } QMD_sem_t;
< #endif
< 
< /* Processor grid storage on finest level */
< typedef struct
< {
< 
<     REAL b[PX0_GRID][PY0_GRID][PZ0_GRID];
< 
< } P0_GRID_S;
< 
< 
< /* Here we use a union of P0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
< 
<     P0_GRID_S s1;
<     REAL s2[PX0_GRID * PY0_GRID * PZ0_GRID];
< 
< } P0_GRID;
< 
< /* Processor grid storage on finest level on the Fine Grid*/
< typedef struct
< {
< 
<     REAL b[FPX0_GRID][FPY0_GRID][FPZ0_GRID];
< 
< } FP0_GRID_S;
< 
< 
< /* Here we use a union of FP0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
<     FP0_GRID_S s1;
<     REAL s2[FPX0_GRID * FPY0_GRID * FPZ0_GRID];
< 
< } FP0_GRID;
< 
< 
< /* Smoothing grid storage on finest level */
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 2][PY0_GRID + 2][PZ0_GRID + 2];
< 
< } S0_GRID_S;
< 
< 
< /* Here we use a union of S0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
< 
<     S0_GRID_S s1;
<     REAL s2[(PX0_GRID + 2) * (PY0_GRID + 2) * (PZ0_GRID + 2)];
< 
< } S0_GRID;
< 
< /* Smoothing grid storage on finest level on the Fine Grid*/
< typedef struct
< {
< 
<     REAL b[FPX0_GRID + 2][FPY0_GRID + 2][FPZ0_GRID + 2];
< 
< } FS0_GRID_S;
< 
< /* Here we use a union of FS0_GRID_S and a single long real array so that */
< /* we can access things in that manner.                              */
< typedef union
< {
< 
<     FS0_GRID_S s1;
<     REAL s2[(FPX0_GRID + 2) * (FPY0_GRID + 2) * (FPZ0_GRID + 2)];
< 
< } FS0_GRID;
< 
< 
< /* For applying higher order finite difference operators */
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 4][PY0_GRID + 4][PZ0_GRID + 4];
< 
< } SS0_GRID;
< 
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 6][PY0_GRID + 6][PZ0_GRID + 6];
< 
< } S30_GRID;
< 
< typedef struct
< {
< 
<     REAL b[PX0_GRID + 10][PY0_GRID + 10][PZ0_GRID + 10];
< 
< } S50_GRID;
< 
< 
< typedef struct
< {
< 
<     REAL b[FPX0_GRID + 4][FPY0_GRID + 4][FPZ0_GRID + 4];
< 
< } FSS0_GRID;
< 
< 
< /** @name PE_CONTROL
<   *
<   * @memo Processor control structure.
<   * 
<   * This is a global structure declared as extern PE_CONTROL pct.
<   * 
<  */
< typedef struct
< {
< 
<     /** Number (rank in MPI terminology) of this processor in this image grid */
<     int thispe, imgpe, thisimg, thisspin, thisgrid;
< 
< 	/** Number of grids (typically 1) per image to be run simultaneously **/
< 	int images, grids;
< 
< 	/* MPI communicators for each code grid (grid_comm) and one (rmg_comm)
< 	 * for all group rank 0 pe's. The later effectively replaces MPI_COMM_WORLD
< 	 * unless you really need all-to-all, even across grids, communication. */
< 	MPI_Comm rmg_comm, img_topo_comm, grid_topo_comm, grid_comm, img_comm, spin_comm;
< 
<     /* determine if this image is processing spin up or spin down. */
<     int spin_flag;
< 
<     /* determine whether to initialize up and down density equally or not */
<     int init_equal_density_flag;
< 
<     /*Whether pe participates in scalapack calculations*/
<     int scalapack_pe;
< 
<     /* Row that given processor handles when using scalapack*/
<     int scalapack_myrow;
<     
<     /* Column that given processor handles when using scalapack*/
<     int scalapack_mycol;
< 
<     /*Processor distribution for scalapack*/
<     int scalapack_nprow;
<     int scalapack_npcol;
< 
<     /** Neighboring processors in three-dimensional space */
<     int neighbors[6];
< 
< 
<     /** Processor x-coordinate for domain decomposition */
<     int pe_x;
<     /** Processor y-coordinate for domain decomposition */
<     int pe_y;
<     /** Processor z-coordinate for domain decomposition */
<     int pe_z;
< 
< 
<     /** Points to start of projector storage for this ion in projector space */
<     //REAL *weight[MAX_IONS];
<     REAL **weight;
< 
< #if FDIFF_BETA
<     /*These are used for non-local force */
<     //REAL *weight_derx[MAX_IONS];
<     REAL **weight_derx;
<     //REAL *weight_dery[MAX_IONS];
<     REAL **weight_dery;
<     //REAL *weight_derz[MAX_IONS];
<     REAL **weight_derz;
< #endif
< 
< 
<     /** An index array which maps the projectors onto the 3-d grid associated
<         with each processor.
<     */
<     //int *nlindex[MAX_IONS];
<     int **nlindex;
<     //int *Qindex[MAX_IONS];
<     int **Qindex;
< 
<     /** An index array which indicate whether the grid map on the current pocessor*/
<     //int *idxflag[MAX_IONS];
<     int **idxflag;
<     //int *Qdvec[MAX_IONS];
<     int **Qdvec;
< 
<     /** Number of points in the nlindex array for each ion */
<     //int idxptrlen[MAX_IONS];
<     int *idxptrlen;
<     //int Qidxptrlen[MAX_IONS];
<     int *Qidxptrlen;
< 
<     /** Number of points in the circle of local projector for each pocessor*/
<     //int lptrlen[MAX_IONS];
<     int *lptrlen;
< 
<     /** Phase shifts for the non-local operators */
<     //REAL *phaseptr[MAX_IONS];
<     REAL **phaseptr;
< 
<     /** Number of projectors associated with each ion. */
<     //int prj_per_ion[MAX_IONS];
<     int *prj_per_ion;
< 
<     /** Points to start of storage for theaugument function*/
<     //REAL *augfunc[MAX_IONS];
<     REAL **augfunc;
< 
<     /** points to start of DnmI function storage for this ion*/
<     //REAL *dnmI[MAX_IONS];
<     REAL **dnmI;
< 
<     /** points to start of qqq storage for this ion*/
<     //REAL *qqq[MAX_IONS];
<     REAL **qqq;
< } PE_CONTROL;
< 
< 
< 
< /**@name STATE
<  *
<  * @memo Wavefunction storage structure */
< typedef struct
< {
< 
<     /** First iteration flag */
<     int firstflag;
< 
<     /** Current estimate of the eigenvalue for this orbital (state). */
<     REAL eig;
< 
<     /** Wavefunction residual error computed by multigrid solver */
<     REAL res;
< 
<     /** Points to the storage area for the real part of the orbital */
<     REAL *psiR;
<     /** Points to the storage area for the imaginary part of the orbital */
<     REAL *psiI;
< 
< 
<     /** Nuclear potential */
<     REAL *vnuc;
<     /** Hartree potential */
<     REAL *vh;
<     /** Exchange correlation potential */
<     REAL *vxc;
<     /** Total potential */
<     REAL *vtot;
< 
<     /** Core charge for non-linear core corrections */
<     REAL *rhocore;
< 
<     /** Grid dimension in the x-coordinate direction on this processor */
<     int dimx;
<     /** Grid dimension in the y-coordinate direction on this processor */
<     int dimy;
<     /** Grid dimension in the z-coordinate direction on this processor */
<     int dimz;
< 
< 
<     /** Grid spacings */
<     REAL hxgrid;
<     REAL hygrid;
<     REAL hzgrid;
< 
< 
<     /** Total basis size on each processor (dimx*dimy*dimz) */
<     int pbasis;
< 
<     /* Total basis size in a smoothing grid on each processor (dimx+2)*(dimy+2)*(dimz+2) */
<     int sbasis;
< 
<     /*8 Index of the orbital */
<     int istate;
< 
< 
<     /** Volume element associated with each real space grid point */
<     REAL vel;
< 
< 
<     /** Occupation of the orbital */
<     REAL occupation;
< 
<     REAL oldeig;
< 
<     /* The offsets and the sizes of the grid that the orbital
<      * is defined on relative to the global grid. These will
<      * be used in the future for cluster boundary condition or
<      * localized orbitals in an Order(N) formulation.
<      */
<     int xoff, yoff, zoff;
<     int xsize, ysize, zsize;
< 
<     /** Index showing which k-point this orbital is associated with */
<     int kidx;
< 
<     /* eigenvalue of the opposite spin for the corresponding orbital (state)*/
<     REAL eig_oppo;
< 
<     /* Hold occupation of the opposite spins orbital*/
<     REAL occupation_oppo;
< 
< } STATE;
< 
< 
< /**@name SPECIES
<  * @memo Species (pseudopotential) control structure
<  * @doc Structure holds data about the pseudopotentials used to
<  * represent different types of atomic species. 
< */
< typedef struct
< {
< 
<     /* symbol read from control file */
<     char pseudo_symbol[32];
< 
<     /* pseudopotential filename */
<     char pseudo_filename[MAX_PATH];
< 
<     /** Description of the species (e.g Atomic carbon generated using 
<      * hamann's code with  rcs=0.80 rcp=0.85 bohr
<      */
<     char description[MAX_CHAR];
< 
<     /** Atomic number */
<     int atomic_number;
< 
<     /** Atomic symbol */
<     char *atomic_symbol;
< 
<     /** Atomic mass */
<     REAL atomic_mass;
< 
<     /** Number of valence electrons */
<     REAL zvalence;
< 
<     /** Gaussian charge parameter used for compensating the 1/r Coulomb
<      * tail of the pseudopotentials
<      */
< 
<     REAL rc;
< 
<     /* Number of grid points in the local in each coordinate direction. 
<      * These used to be L0_LDIM and L0_NLDIM.
<      */
<     int ldim;
<     int nldim;
<     int nlfdim;
<     int qdim;
< 
< 
<     /* These are input parameters in the pseudopotential file. They represent the
<      * real radii that are used in generating ldim and nldim.
<      */
<     REAL lradius;
<     REAL nlradius;
<     REAL qradius;
< 
<     /*Radius for milliken analysis*/
<     REAL mill_radius;
<     /*Radius in number of grid points*/
<     int mill_dim;
<     /*Number of radial atomic wave functions - these depend on l only, not on m*/
<     int num_atomic_waves;
<     /*l-numbers for states for which we have atomic orbitals*/
<     int lstate_atomic_wave[5];
<     /*Sum of all atomic states (with different l or m numbers*/
<     int sum_atomic_waves;
< 
<     /*This will store name of atomic wavefunctions, such as s, px, py, pz, dxx etc*/
<     char atomic_wave_symbol[20][12];
< 
< 
<     /** Number of radial grid points in the pseudopotential file */
<     int rg_points;
< 
<     /* Log mesh parameter, where aa=exp(-aasf)/Z, bb=1.0/bbsf */
<     REAL aa, bb;
< 
<     /** Non-linear core correction flag */
<     int nlccflag;
< 
<     /* Number of potentials */
<     int num_potentials;
< 
<     /* L-values for the reference states */
<     int lval[10];
< 
<     /* L-value for local pseudopotential state */
<     int local;
< 
<     /* Index for local pseudopotential state */
<     int localidx;
< 
<     /*Number of grid points in the beta function */
<     int kkbeta;
< 
<     /*matrix ddd0(nbeta,nbeta) */
<     REAL ddd0[18][18];
<     REAL ddd[18][18];
< 
<     /*matrix qqq(nbeta,nbeta) */
<     REAL qqq[18][18];
< 
<     /*the number of L=|l1-l2|.....|l1+l2|, we limit nlc <=5 */
<     int nlc;
< 
<     /*the number of component in polynomial of the pseudized Q_I(r) function we limit nqf<=10 */
<     int nqf;
< 
<     /*L-independent inner coutoff radii rinner for Q_I(r) function */
<     REAL rinner[5];
< 
<     /* ultrosoft Vanderbilt Qnm_rad(r) function and */
<     REAL *qnm;
<     REAL *qnmlig;
<     REAL *drqnmlig;
< 
<     /* the coefficient for pseudosation of Qnm_L(r) */
<     REAL *qfcoef;
< 
<     /* Logarithmic radial mesh information */
<     REAL r[MAX_RGRID];
<     REAL rab[MAX_RGRID];
< 
< 
<     /* Local Pseudopotentials */
<     REAL vloc0[MAX_RGRID];
< 
<     /* Core charge radial grids */
<     REAL cr[MAX_RGRID];
< 
< 
<     /* Pseudo atomic valence density */
<     /*REAL avdens[MAX_RGRID];*/
<     REAL **atomic_wave;
< 
< 
<     /* Pseudo atomic core density */
<     REAL rspsco[MAX_RGRID];
< 
<     /*the L-value for the beta function */
<     int llbeta[MAX_NB];
< 
<     /*utrosoft Vanderbilt beta_n(r) function on radial grid */
<     REAL beta[MAX_NB][MAX_RGRID];
< 
< 
<     /* Total number of projectors */
<     int nbeta;
< 
< 
<     /* Linear interpolation storage for the compensated local potential
<      * and for it's radial derivative.
<      */
<     REAL localig[MAX_LOCAL_LIG];
<     REAL drlocalig[MAX_LOCAL_LIG];
< 
<     /* Linear interpolation storage for the core charge density */
<     REAL rhocorelig[MAX_LOCAL_LIG];
< 
<     /* Utrosoft Vandbelit Projectors on linear interpolation grid */
<     REAL betalig[MAX_NB][MAX_LOCAL_LIG];
< 
<     /* Radial derivatives of the Utrosoft Vandbelit Projectors on linear interpolation grid */
<     REAL drbetalig[MAX_NB][MAX_LOCAL_LIG];
< 
<     /* Local potential linear interpolation grid spacing */
<     REAL drlig;
< 
<     /* Non-local linear interpolation grid spacing */
<     REAL drnlig;
< 
<     /* Qfunction linear interpolation grid spacing */
<     REAL drqlig;
< 
< 
<     /* Pseudopotential filtering parameters */
<     REAL lrcut;                 /* Real space local cutoff */
<     REAL nlrcut[4];             /*Real space nonlocal cutoff */
<     REAL rwidth;                /* Real-space width parameter */
<     REAL gwidth;                /* G-space width parameter */
< 
< 
<     /*Total number (of what exactly ???) */
<     int num_projectors;
< 
< 
<     /*This will store results of forward fourier transform on the coarse grid */
<     fftw_complex *forward_beta;
< 
< #if !FDIFF_BETA
<     /*This will store results of forward fourier transform for derivatives of beta on the coarse grid */
<     fftw_complex *forward_derbeta_x;
<     fftw_complex *forward_derbeta_y;
<     fftw_complex *forward_derbeta_z;
< #endif
< 
<     /*Backwards wisdom for fftw */
<     char *backward_wisdom;
< 
< 
< } SPECIES;
< 
< 
< /* Structure for storing species information for internal pseudopotentials */
< typedef struct
< {
<     char name[4];
<     REAL valence;
<     REAL mass;
<     REAL rc;
<     int nlccflag;
<     int maxl;
<     int local;
< } ISPECIES;
< 
< 
< 
< /*Structure for storing PDB information
<  * Each ion should have it*/
< typedef struct
< {
< 
< /* 1 -  6  Record name*/
< char record_name[7];
< 
< /* 7 - 11 Atom serial number*/
< int serial_num;
< 
< /*13 - 16  Atom name*/
< char name[5];
< 
< /* 17 Alternate location indicator.*/
< char altLoc[2];
< 
< /* 18 - 20 Residue name*/
< char resName[4];
< 
< /* 22 Chain identifier*/
< char chainID[2];
< 
< /* 23 - 26 Residue sequence number*/
< int resSeq;
< 
< /* 27 Code for insertion of residues*/
< char iCode[2];
< 
< /* 55 - 60 Occupancy*/
< REAL occupancy;
< 
< /* 61 - 66 Temperature factor*/
< REAL tempFactor;
< 
< /* 77 - 78  Element symbol, right-justified. */
< char element[3];
< 
< /*79 - 80  Charge on the atom.*/
< char charge[3];
< 
< } PDB_INFO;
< 
< 
< 
< 
< /* Ion structure */
< typedef struct
< {
< 
<     /* Initial physical coordinates at start of run */
<     REAL icrds[3];
< 
<     /* Actual Physical coordinates at current time step */
<     REAL crds[3];
< 
<     /* Positions at the previous time step */
<     REAL ocrds[3];
< 
<     /* Initial crystal coordinates at start of run */
<     REAL ixtal[3];
< 
<     /* Actual crystal coordinates at current time step */
<     REAL xtal[3];
< 
<     /* Crystal coordinates  at the previous time step */
<     REAL oxtal[3];
< 
<     /*Position of ion relative to the middle of non-local box around the ion 
<      *          * determined in get_nlop, AIget_cindex sets this up*/
<     REAL nlcrds[3];
< 
< 
<     /* Coordinates of the corner of the grid that the local */
<     /* difference potential is nonzero on.                  */
<     REAL lxcstart;
<     REAL lycstart;
<     REAL lzcstart;
< 
< 
<     /* Coordinates of the corner of the grid that the non-local */
<     /* potential is nonzero on.                                 */
<     REAL nlxcstart;
<     REAL nlycstart;
<     REAL nlzcstart;
< 
< 
<     /* Coordinates of the corner of the grid that the Qfunction */
<     /* potential is nonzero on.                                 */
<     REAL Qxcstart;
<     REAL Qycstart;
<     REAL Qzcstart;
< 
< 
<     /* Integer species type when using a raw pseudopotential */
<     int species;
< 
<     /* Forces on the ion */
<     REAL force[4][3];
< 
<     /* Current velocity of the ion */
<     REAL velocity[3];
< 
<     /* Kleinman-Bylander normalization coefficients */
<     REAL pd[(MAX_L + 1) * (MAX_L + 1)];
< 
<     /* Milliken normalization coefficients */
<     REAL mnorm[(MAX_L + 1) * (MAX_L + 1)];
< 
<     /* Total number of projectors */
<     int prjcount;
< 
<     /* Movable flag */
<     int movable;
< 
< 	/* Movement constraint: float[3] vector, int constraint_type (0=disabled, 1=in-plane, 2=along vector) */
< 	REAL constraint[3];
< 	int constraint_type;
< 
<     /* Stored non-local projectors */
<     REAL *oldsintR;
<     REAL *oldsintI;
<     REAL *newsintR;
<     REAL *newsintI;
< 
<     /* Stores sine and cosine of a phase factor for backwards fourier transform */
<     REAL *fftw_phase_sin;
<     REAL *fftw_phase_cos;
< 
< 
<     /*Stores PDB information*/
<     PDB_INFO pdb;
< 
< 
< } ION;
< 
< 
< 
< /* multigrid-parameter structure */
< typedef struct
< {
< 
<     /* number of global-grid pre/post smoothings and timestep */
<     REAL gl_step;
<     int gl_pre;
<     int gl_pst;
< 
<     /* timestep for the subiteration */
<     REAL sb_step;
< 
<     /* timestep for the Richardson-Iteration */
<     REAL ri_step;
< 
<     /* lowest MG level */
<     int levels;
< 
< 
< } MG_PARM;
< 
< /* Nose control structure */
< typedef struct
< {
< 
<     /* number of atoms allowed to move */
<     int N;
< 
<     /* ionic target temperature in Kelvin */
<     REAL temp;
< 
<     /* ionic target kinetic energy */
<     REAL k0;
< 
<     /* randomize velocity flag */
<     int randomvel;
< 
<     /* Nose oscillation frequency */
<     REAL fNose;
< 
<     /* number of thermostats used */
<     int m;
< 
<     /* thermostat positions,velocities,masses and forces */
<     REAL xx[10];
<     REAL xv[10];
<     REAL xq[10];
<     REAL xf[4][10];
< 
< } FINITE_T_PARM;
< 
< 
< /** @name KPOINT
<  * @memo Holds data specific to individual k-points.
<  */
< typedef struct
< {
< 
<     /** The index of the k-point for backreferencing */
<     int kidx;
< 
<     /** The k-point */
<     REAL kpt[3];
< 
<     /** The corresponding vector */
<     REAL kvec[3];
< 
<     /** The weight associated with the k-point */
<     REAL kweight;
< 
<     /** The magnitude of the k-vector */
<     REAL kmag;
< 
<     /* The orbital structure for this k-point */
<     STATE *kstate;
< 
< 
<     /* Mean min, and max wavefunction residuals for occupied space */
<     REAL meanres;
<     REAL minres;
<     REAL maxres;
< 
<     /* Total energies */
<     REAL ES;
<     REAL NUC;
<     REAL KE;
<     REAL XC;
<     REAL NL;
<     REAL II;
<     REAL TOTAL;
< 
< } KPOINT;
< 
< 
< 
< 
< /** @name CONTROL
<   @memo Main control structure
<  
<   This is a global structure declared as extern CONTROL ct
<  
<  */
< typedef struct
< {
< 
< #ifdef SMP
<     /* Number of threads to run concurrently. We always 
<      * use one thread per eigenfunction but it's inefficient 
<      * to have more threads than the number of CPU's available
<      * running concurrently. Defaults to compile time parameter 
<      * of 1 but can be overridden by setting the environment 
<      * variable QMD_NUM_THREADS to any value up to MAX_THREADS.
<      */
<     int thread_concurrency;
<     int num_threads;
< 
<     /* When running on a cluster this is the total number of nodes
<      * in the cluster.
<      */
<     int num_nodes;
< 
<     /* While this is the identity of this node */
<     int this_node;
< 
<     /* And this is the space offset of this node */
<     int node_space_offset;
< 
<     /* And this is the number of space points handled by this node */
<     int node_space_size;
< #endif
< 
<     /** Description of the run. */
<     char description[MAX_CHAR];
< 
<     /* time at which run started */
<     REAL time0;
< 
<     /** Name of the input control file. Passed as a command line argument
<      *
<      *  Example:
<      *  bash$  md in.diamond8
<      */
<     char cfile[MAX_PATH];
< 
<     /** HAndle of the output log file. Constructed from command line argument */
<     FILE *logfile;
< 
<     /** Input file name to read wavefunctions from when doing a restart */
<     char infile[MAX_PATH];
< 
<     /** Input file name to write wavefunctions to */
<     /* Output file name */
<     char outfile[MAX_PATH];
< 
<     /** File to read the pseudopotentials from */
<     /*  char pspfile[MAX_PATH]; */
< 
<     /** Initial run flag. Read from the input file. 0=initial run otherwise a restart */
<     int runflag;
< 
<     /* output z-average of states */
<     int zaverage;
< 
<     /* number of state to output */
<     int plot_state;
< 
<     /* Exchage-Correlation flag */
<     int xctype;
< 
<     /** Boundary condition flag. Read from the input file. 0=periodic, 1=cluster, 2=surface */
<     int boundaryflag;
< 
<     /* Coordinate input flag: crystal or cartesian */
<     int crd_flag;
< 
<     /* Maximum number of MD steps */
<     int max_md_steps;
< 
<     /* Maximum number of fast relax steps */
<     int max_rlx_steps;
< 
<     /* Maximum number of rmg meta loops (NEB, ARTS, etc.) */
<     int max_rmg_steps;
< 
<     /* MD steps iterator */
<     int md_steps;
< 
<     /* Maximum number of SCF steps in a MD steps */
<     int max_scf_steps;
< 
<     /* Total number of SCF steps done */
<     int total_scf_steps;
< 
<     /* SCF steps iterator */
<     int scf_steps;
< 
<     /* override occupations */
<     int override_occ;
< 
<     /* Override current ionic positions (in control file) with positions from wave file (during restart) */
<     int override_current;
< 
<     /* Override initial ionic positions (in control file) with positions from wave file (during restart) */
<     int override_initial;
< 
<     /* convergence criterion */
<     REAL thr_rms;
< 
<     /* force convergence criterion */
<     REAL thr_frc;
< 
<     /* Number of steps after which to perform checkpointing */
<     int checkpoint;
< 
<     /* Number of steps after which to output results */
<     int outcount;
< 
<     /** Sorting flag for wavefunctions. Read from input file. 0=no sort, 1=sort */
<     int sortflag;
< 
<     /** Number of states */
<     int num_states;
< 
<     /* Number of states for the opposite spin*/
<     int num_states_oppo; 
< 
<     /*Number of states for spin up and down used for initialization*/
<     int num_states_up, num_states_down;
< 
<     /** Number of unoccupied states above Fermi level */
<     int num_unocc_states;
< 
<     /** string to store repeat count occupations */
<     char occupation_str[256];
< 
<     /*string to store repeat count occupations for spin up*/
<     char occupation_str_spin_up[256];
< 
<     /*string to store repeat count occupations for spin down*/
<     char occupation_str_spin_down[256]; 
<     
< 
<     /** Number of ions */
<     int num_ions;
< 
<     /** Ion structure */
<     ION *ions;
< 
<     /** Number of species */
<     int num_species;
< 
<     /* Cutoff parameter */
<     REAL cparm;
<     REAL betacparm;
<     REAL qcparm;
< 
<     /** Total conpensating charge density */
<     REAL crho;
< 
<     /** Total charge in supercell */
<     REAL tcharge;
< 
<     /** Species structure 
<      * @see SPECIES */
<     SPECIES *sp;
< 
<     /** the fine grid size on each coarse grid cell */
<     int nxfgrid;
<     int nyfgrid;
<     int nzfgrid;
< 
<     /** Global uniform grid spacing in x */
<     REAL hxgrid;
< 
<     /** Global uniform grid spacing in y */
<     REAL hygrid;
< 
<     /** Global uniform grid spacing in z */
<     REAL hzgrid;
< 
<     /** The fine uniform grid spacing in x */
<     REAL hxxgrid;
< 
<     /** The fine uniform grid spacing in y */
<     REAL hyygrid;
< 
<     /** The fine uniform grid spacing in z */
<     REAL hzzgrid;
< 
<     /** bravais lattice type */
<     int ibrav;
< 
<     /** Lattice information */
<     REAL celldm[6];
< 
<     /* lattice vectors */
<     REAL a0[3];
<     REAL a1[3];
<     REAL a2[3];
< 
<     /** Total cell volume */
<     REAL omega;
< 
<     /* lengths of the sides of the supercell */
<     REAL xside;
<     REAL yside;
<     REAL zside;
< 
<     /* This is the max of nldim for any species cubed */
<     int max_nlpoints;
<     int max_nlfpoints;
<     int max_Qpoints;
< 
<     /** Maximum grid spacing in any coordinate direction */
<     REAL hmaxgrid;
< 
< 
<     /** Minimum grid spacing in any coordinate direction */
<     REAL hmingrid;
< 
< 
<     /** Grid anisotropy defined as the ratio of hmaxgrid to hmingrid. A value larger than 1.05 can lead to convergence problems. */
<     REAL anisotropy;
< 
< 
<     /** Volume element associated with each grid point */
<     REAL vel;
<     REAL vel_f;
< 
< 
<     /** Physical grid basis size */
<     int nbasis;
< 
< 
<     /** Density mixing parameter. Typical values range from 0.2 to 0.9, while larger values provide faster convergence as long as they are stable. */
<     REAL mix;
< 
< 
<     /* Projector mixing parameter */
<     REAL prjmix;
< 
<     /* Global uniform grid corner */
<     REAL xcstart;
<     REAL ycstart;
<     REAL zcstart;
< 
< 
<     /* Hartree potential offset from wavefunction grid */
<     int vh_xoffset;
<     int vh_yoffset;
<     int vh_zoffset;
< 
< 
<     /* Hartree potential grid sizes */
<     int vh_nxgrid;
<     int vh_nygrid;
<     int vh_nzgrid;
< 
< 
<     /* Hartree potential grid sizes per domain */
<     int vh_pxgrid;
<     int vh_pygrid;
<     int vh_pzgrid;
< 
< 
<     /* Total points in hartree potential per domain */
<     int vh_pbasis;
< 
< 
<     /* Wavefunction grid sizes */
<     int psi_nxgrid;
<     int psi_fnxgrid;
<     int psi_nygrid;
<     int psi_fnygrid;
<     int psi_nzgrid;
<     int psi_fnzgrid;
< 
<     /* Total points for wavefunctions */
<     int psi_nbasis;
<     int psi_fnbasis;
< 
<     /* Decoupled hartree potential */
<     REAL *vh_ext;
< 
< 
<     /* Mean min, and max wavefunction residuals for occupied space */
<     REAL meanres;
<     REAL minres;
<     REAL maxres;
< 
<     /* total ionic charge */
<     REAL ionic_charge;
< 
<     /* Variable occupation stuff */
<     REAL nel;
< 
<     int occ_flag;
< 
<     REAL occ_width;
< 
<     REAL occ_mix;
< 
<     /** total background smearing charge -- for charged supercells */
<     REAL background_charge;
< 
< 
<     /** Multigrid parameters for the eigenvalue solver */
<     MG_PARM eig_parm;
< 
<     /** Multigrid parameters for the poisson solver */
<     MG_PARM poi_parm;
< 
< 
<     /** Nose paramters */
<     FINITE_T_PARM nose;
< 
<     /* force pointer array */
<     int fpt[4];
< 
<     /* temperature control */
<     int tcontrol;
< 
<     /* md integrate level */
<     int mdorder;
< 
<     /* movie flags */
<     int rmvmovie, chmovie, xbsmovie;
< 
<     /* Milliken population flags. */
<     int domilliken;
<     int milliken;
< 
<     /* Diagonalization flag and period */
<     int initdiag;
<     int diag;
<     int end_diag;
< 
<     /* How many steps between writeout of eigenvalues*/
<     int write_eigvals_period;
< 
<     /* Diagonalizations during the md step */
<     int mddiag1;
<     int mddiag2;
< 
<     /** Force flag. 0=don't compute forces, 1=compute forces */
<     int forceflag;
< 
<     /* Whether to write full memory usage report at the end of calculation */
<     int write_memory_report;
< 
<     /** Ionic motion timestep */
<     REAL iondt;
< 
< 
<     /** Ionic motion energy */
<     REAL ionke;
< 
< 
<     /* Total energies */
<     REAL ES;
<     REAL NUC;
<     REAL KE;
<     REAL XC;
<     REAL NL;
<     REAL II;
<     REAL TOTAL;
< 
<     /* fermi energy */
<     REAL efermi;
< 
<     /** Total number of k-points being used in the calculation */
<     int num_kpts;
< 
< 
<     /** K-point control structure */
<     KPOINT *kp;
< 
<     /** Throttles data transfer rates when writing wavefunctions to disk
<      *
<      * On clusters with NFS mounted filesystems having all nodes
<      * dump there data at the same time can cause network congestion
<      * and hangups so wait_flag can be set in the input file to throttle
<      * the total bandwidth being written. */
<     int wait_flag;
< 
<     /** The maximum number of projectors for any species */
<     int max_nl;
< 
<     /*Maximum value of nldim for any species */
<     int max_nldim;
< 
<     /*This keeps track whether ct.fftw_wisdom_setup was setup or not so that
<      * we know whether to release wisdom memory at the end or not*/
<     int fftw_wisdom_setup;
< 
< 
<     /*Interpolation flags */
<     int interp_flag;
< 
<     /*Order of B-spline */
<     int interp_order;
< 
<     /*Order of trade_image used in interpolation */
<     int interp_trade;
< 
<     /* the external electric field */
<     REAL e_field;
< 
<     REAL x_field_0;
< 
<     REAL y_field_0;
< 
<     REAL z_field_0;
< 
< 
< } CONTROL;
< 
< 
< #ifdef SMP
< 
< /* Thread control structures */
< typedef struct
< {
< 
<     /* Thread ID number */
<     int tid;
< 
<     /* These volatiles are used as synchronization variables for the threads */
<     volatile int start;
< 
<     /* With the complex option this lets the threads know which k-point is
<      * currently being worked on in ortho and subdiag. */
<     int kidx;
< 
<     /* Pointer to state array used by each thread */
<     STATE *my_states;
< 
<     /* Local variable -- summed to obtain total charge for all orbitals */
<     REAL tcharge;
< 
<     /* Spacial offset for the thread */
<     int offset;
< 
<     /* Points to base of distributed storage array for this thread */
<     REAL *base_mem;
< 
<     /* Points to base of distributed scratch array for this thread */
<     REAL *scratch1;
< 
<     /* Number of points per wavefunction in the distributed storage array */
<     int numpt;
< 
<     /* leading dimension of the distributed wave function storage array */
<     int lda;
< 
<     /* Local copies of eigenvalues and occupations for this thread */
<     REAL *eigs;
<     REAL *occs;
< 
<     /* Force contributions computed by this thread */
<     REAL force[MAX_IONS][3];
< 
<     /* Pointer to dynamically allocated arrays of size ct.num_states*ct.num_states */
<     /* that is required in ortho. Each thread has it's own copy */
<     REAL *darr;
<     REAL *barr;
< 
< 
<     /* The same array as referenced by darr but this copy is 
<      *allocated in the main program rather than in one of the threads.
<      */
<     REAL *farr;
< 
< 
<     REAL *rho;
<     REAL *rhocore;
<     REAL *vtot;
<     REAL *vnuc;
< 
<     /* Pointers to the non-local potential index list 
<      *and to the projectors themselves */
<     int *nlindex;
<     REAL *projectors;
< 
< 
< } SCF_THREAD_CONTROL;
< #endif
< 
< 
< 
< /* Extern declaration for the main control structure */
< extern CONTROL ct;
< 
< 
< /* Extern declaration for the processor control structure */
< extern PE_CONTROL pct; 
< 
< 
< /* Extern declarations for thread control structures */
< #ifdef SMP
< extern SCF_THREAD_CONTROL thread_control[];
< #endif
< 
1375,1978d78
< /* Function prototypes */
< void app_4del2 (S0_GRID *f, P0_GRID *work);
< REAL app_del2c (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                 REAL gridhx, REAL gridhy, REAL gridhz);
< void app6_del2 (REAL *rho, P0_GRID * work);
< void app6_del2f (REAL *rho, FP0_GRID * work);
< void app_smooth (S0_GRID *f, S0_GRID *work, REAL sfac);
< /*void app_smooth1(FS0_GRID *f, FS0_GRID *work);*/
< void app_cir_sixth (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_ortho (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_bcc (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_fcc (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< void app_cir_hex (REAL *a, REAL *b, int dimx, int dimy, int dimz);
< REAL app_cilr (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_bcc (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_fcc (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_hex (REAL *a, REAL *b, REAL *c, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cilr_ortho (REAL *a, REAL *b, REAL *c, int dimx, int dimy,
<                      int dimz, REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil (REAL *a, REAL *b, int dimx, int dimy, int dimz, REAL gridhx,
<               REAL gridhy, REAL gridhz);
< REAL app_cil_sixth (REAL *psi, REAL *b, int dimx, int dimy, int dimz,
<                     REAL gridhx, REAL gridhy, REAL gridhz);
< void app_grad (REAL  * rho, P0_GRID * wx, P0_GRID * wy, P0_GRID * wz);
< void app_gradf (REAL * rho, FP0_GRID * wx, FP0_GRID * wy, FP0_GRID * wz);
< void constrain(ION *iptr);
< void corlyp (REAL *dp, REAL *dm, REAL *dp1, REAL *dm1, REAL *dp2, REAL *dm2, REAL *ec,
<              REAL *vcp0, REAL *vcm0, int *ndm);
< void cross_product (REAL *a, REAL *b, REAL *c);
< void destroy_fftw_wisdom (void);
< void eval_residual (REAL *mat, REAL *f_mat, int dimx, int dimy, int dimz,
<                     REAL gridhx, REAL gridhy, REAL gridhz, REAL *res);
< void solv_pois (REAL *vmat, REAL *fmat, REAL *work,
<                 int dimx, int dimy, int dimz, REAL gridhx,
<                 REAL gridhy, REAL gridhz, REAL step);
< REAL fill (STATE *states, REAL width, REAL nel, REAL mix,
<            int num_st, int occ_flag);
< REAL fill_spin(STATE *states_up, REAL * eigval_dn, REAL width, REAL nel, REAL mix, int num_st, int occ_flag);
< 
< void find_phase (int nldim, REAL *nlcdrs, REAL *phase_sin,
<                  REAL *phase_cos);
< void finish_release_mem(STATE *states);
< void genvpsi (REAL *psi, REAL *twovpsi, REAL *pvtot, REAL *pvnl,
<               REAL *kd, REAL kmag, int dimx, int dimy, int dimz);
< void get_nlop (void);
< void get_weight (void);
< void get_phase (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_nlop_smp (int tid);
< void get_eig (STATE *states, P0_GRID *vxc, P0_GRID *vh, P0_GRID *vnuc);
< char *get_num (char *str);
< void get_te (REAL *rho, REAL *rhocore, REAL *rhoc, REAL *vh, REAL *vxc,
<              STATE *states);
< void get_te_spin (REAL *rho, REAL *rho_oppo, REAL *rhocore, REAL *rhoc, REAL *vh, REAL *vxc,
<              STATE *states);
< 
< void get_vxc (REAL *rho, REAL *rhocore, REAL *vxc);
< void get_vxc_spin (REAL *rho, REAL * rho_oppo, REAL *rhocore, REAL *vxc);
< 
< 
< void get_zdens (STATE *states, int state, REAL *zvec);
< void xclda_pz81 (REAL *rho, REAL *vxc);
< void exclda_pz81 (REAL *rho, REAL *exc);
< 
< /* new lda function incorporating both  1981 and 1994 monte carlo data */
< void xclda(REAL *rho, REAL *vxc, REAL *exc);
< void slater(REAL rs, REAL *ex, REAL *vx);
< void pz(REAL rs, int iflag, REAL *ec, REAL *vc); 
< 
< /* lsda exchange correlation functional */
< void xclsda_spin(REAL *rho, REAL *rho_oppo, REAL *vxc, REAL *exc);
< void slater_spin(REAL arhox, REAL zeta, REAL *ex, REAL *vx, REAL *vx_oppo);
< void pz_spin(REAL rs, REAL zeta, REAL *ec, REAL *vc, REAL *vc_oppo);
< void pz_polarized(REAL rs, REAL *ec, REAL *vc);
< void pw_spin (REAL rs, REAL zeta, REAL *ec, REAL *vcup, REAL *vcdw);
< void pw (REAL rs, int iflag, REAL *ec, REAL *vc) ;
< 
< 
< double mu_pz (double rho);
< double e_pz (double rho);
< void xcgga (REAL *rho, REAL *vxc, REAL *exc, int flag);
< void xcgga_spin (REAL *rho, REAL *rho_oppo, REAL *vxc, REAL *exc, int flag);
< 
< 
< /* exchange correlation functional for PBE */
< 
< void gcxcpbe_spin(REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< void pbex (REAL rho, REAL grho, int iflag, REAL *sx, REAL *v1x, REAL *v2x);
< void pbec_spin (REAL rho, REAL zeta, REAL grho, int iflag, REAL *sc, REAL *v1cup, REAL *v1cdw, REAL *v2c);
< 
< void gcxcpbe (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< 
< void pbec (REAL rho, REAL grad, int iflag, REAL *sc, REAL *v1c, REAL *v2c);
< 
< 
< 
< /* becke88 exchange and perdew86 correlation */
< 
< void becke88 ( REAL rho, REAL grho, REAL *sx, REAL *v1x, REAL *v2x );
< void perdew86 ( REAL rho, REAL grho, REAL *sc, REAL *v1c, REAL *v2c );
< void gcxbcp (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< void perdew86_spin ( REAL rho, REAL zeta, REAL grho, REAL *sc, REAL *v1cup, REAL *v1cdw, REAL *v2c );
< void becke88_spin ( REAL rho, REAL grho, REAL *sx, REAL *v1x, REAL *v2x );
< void gcxbcp_spin (REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< 
< 
< /* PW91 exchange correlation */
< 
< void ggax(REAL rho, REAL grho, REAL *sx, REAL *v1x, REAL *v2x);
< void ggac (REAL rho, REAL grho, REAL *sc, REAL *v1c, REAL *v2c);
< void ggac_spin (REAL rho, REAL zeta, REAL grho, REAL *sc, REAL *v1cup, REAL *v1cdw, REAL *v2c);
< void gcxcpw91 (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< void gcxcpw91_spin(REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< 
< 
< /* BLYP exchange correlation */
< 
< void lyp ( REAL rs, REAL *ec, REAL *vc );
< void glyp ( REAL rho, REAL grho, REAL *sc, REAL *v1c, REAL *v2c );
< void lsd_lyp ( REAL rho, REAL zeta, REAL * elyp, REAL * valyp, REAL * vblyp );
< void lsd_glyp ( REAL rhoa, REAL rhob, REAL grhoaa, REAL grhoab2, REAL grhobb, REAL *sc, REAL *v1ca, REAL *v2ca, REAL *v1cb, REAL *v2cb, REAL *v2cab );
< void gcxcblyp (REAL rho, REAL grad, REAL *enxc, REAL *vxc1, REAL *vxc2);
< void gcxcblyp_spin (REAL rho_up, REAL rho_dw,
<   REAL grad_up, REAL grad_dw, REAL grad_updw2, REAL *enxc,
<   REAL *vxc1_up, REAL *vxc1_dw, REAL *vxc2_upup, REAL *vxc2_dwdw,
<   REAL *vxc2_updw, REAL *vxc2_dwup);
< 
< 
< 
< void gram (KPOINT *kpoint, REAL h, int numst, int maxst, int numpt,
<            int maxpt);
< int get_input (FILE *fh, char *id, void *dest, unsigned int flag, char *def);
< REAL get_ke (STATE *sp, int tid);
< void get_vh (REAL *rho, REAL *rhoc, REAL *vh, int cycles, int maxlevel);
< char *get_symbol (int atomic_number);
< void global_sums (REAL *vect, int *length);
< void global_sums_spin (REAL *vect, int *length);
< void init (REAL *vh, REAL *rho, REAL *rhocore, REAL *rhoc, STATE *states,
<            REAL *vnuc, REAL *vxc);
< void init_spin (REAL *vh, REAL *rho, REAL *rho_oppo, REAL *rhocore, REAL *rhoc, STATE *states,
<            REAL *vnuc, REAL *vxc);
< void init_derweight (void);
< void init_derweight_s (SPECIES *sp, fftw_complex *rtptr_x,
<                        fftw_complex *rtptr_y, fftw_complex *rtptr_z, int ip,
<                        fftwnd_plan p1);
< void init_derweight_p (SPECIES *sp, fftw_complex *rtptr_x,
<                        fftw_complex *rtptr_y, fftw_complex *rtptr_z, int ip,
<                        fftwnd_plan p1);
< void init_derweight_d (SPECIES *sp, fftw_complex *rtptr_x,
<                        fftw_complex *rtptr_y, fftw_complex *rtptr_z, int ip,
<                        fftwnd_plan p1);
< void init_fftw_wisdom (void);
< void init_kbr (void);
< void init_IO ( int argc, char **argv );
< void init_pe (void);
< void init_img_topo ( int dimensionality );
< void init_pegrid (void);
< STATE *init_states (void);
< STATE *init_states_spin(void);
< void init_weight (void);
< void init_weight_s (SPECIES *sp, fftw_complex *rtptr, int ip,
<                     fftwnd_plan p1);
< void init_weight_p (SPECIES *sp, fftw_complex *rtptr, int ip,
<                     fftwnd_plan p1);
< void init_weight_d (SPECIES *sp, fftw_complex *rtptr, int ip,
<                     fftwnd_plan p1);
< void init_wf (STATE *states);
< void init_nuc (REAL *vnuc, REAL *rhoc, REAL *rhocore);
< void init_pos (void);
< void init_sym (void);
< void symmetrize_rho (FP0_GRID *rho);
< void symforce (void);
< void cforce (P0_GRID *rho, P0_GRID *vh);
< void mgrid_solv (REAL *v_mat, REAL *f_mat, REAL *work,
<                  int dimx, int dimy, int dimz, REAL gridhx, REAL gridhy,
<                  REAL gridhz, int level, int *nb_ids, int max_levels,
<                  int *pre_cyc, int *post_cyc, int mu_cyc, REAL step);
< void rmg_timings (int what, REAL time, int tid);
< REAL minimage (ION *ip1, ION *ip2, REAL *xtal_r);
< REAL my_crtc (void);
< /* Local function prototypes */
< FILE *open_xbs_movie (char *filename);
< int open_wave_file (char *filename);
< void xbsmovie (FILE *movie);
< void ortho_half (STATE *states);
< void ortho_bcc (STATE *states);
< void output_eigenvalues( STATE *states, int ikbs, int iscf );
< void pe2xyz (int pe, int *x, int *y, int *z);
< void pack_ptos (REAL *sg, REAL *pg, int dimx, int dimy, int dimz);
< void pack_stop (REAL *sg, REAL *pg, int dimx, int dimy, int dimz);
< void pack_stop_axpy (REAL *sg, REAL *pg, REAL alpha, int dimx, int dimy,
<                      int dimz);
< void pack_ptos_trade (REAL *sg, REAL *pg, int dimx, int dimy, int dimz);
< void pack_vhstod (REAL *s, REAL *d, int dimx, int dimy, int dimz);
< void pack_vhdtos (REAL *s, REAL *d, int dimx, int dimy, int dimz);
< double radint (double *f, double *r, int n, double al);
< REAL radint1 (REAL *f, REAL *r, REAL *dr_di, int n);
< void radiff (double *f, double *df, double *r, int n, double al);
< void ra2diff (double *f, double *df, double *r, int n, double al);
< void ranv (void);
< void read_control(void);
< void write_pdb (void);
< int read_atom_line(char *species, REAL *crds, int *movable, FILE *fhand, char *tbuf, int index);
< int assign_species (CONTROL * c, char *buf);
< void read_data (char *name, REAL *vh, REAL *rho, REAL *vxc,
<                 STATE *states);
< void read_data_spin (char *name, REAL *vh, REAL *rho, REAL *rho_oppo, REAL *vxc,
<                 STATE *states);
< 
< void read_pseudo (void);
< REAL real_sum_all (REAL x);
< REAL real_sum_all_spin (REAL x);
< REAL real_min_all (REAL x);
< 
< 
< void reset_timers (void);
< /*void scf(STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<            REAL *rho, REAL *rhocore, REAL *rhoc, int *CONVERGENCE);*/
< void sortpsi (STATE *states);
< /*void subdiag(STATE *states, REAL *vh, REAL *vnuc, REAL *vxc);*/
< void trade_images (REAL *mat, int dimx, int dimy, int dimz, int *nb_ids);
< void trade_imagesx (REAL *f, REAL *w, int dimx, int dimy, int dimz,
<                     int images);
< void set_bc (REAL *mat, int dimx, int dimy, int dimz, int images, REAL val);
< void set_bcx (REAL *mat, int dimx, int dimy, int dimz, int images, REAL val);
< void getpoi_bc (REAL *rho, REAL *vh_bc, int dimx, int dimy, int dimz);
< /*void trade_images2(S0_GRID *f, SS0_GRID *w);
< void trade_images2f(FS0_GRID *f, FSS0_GRID *w);
< void trade_images3(S0_GRID *f, S30_GRID *w);
< void trade_images5(S0_GRID *f, S50_GRID *w);*/
< void vol_rho (P0_GRID *rho, int step);
< void vol_wf (STATE *states, int state, int step);
< void write_avgd (REAL *rho);
< void write_avgv (REAL *vh, REAL *vnuc);
< void write_zstates (STATE *states);
< void write_data (char *name, REAL *vh, REAL *rho, REAL *vxc,
<                  STATE *states);
< 
< void write_data_spin (char *name, REAL *vh, REAL *rho, REAL *rho_oppo, REAL *vxc,
<                  STATE *states);
< void write_header (void);
< void write_occ (STATE *states);
< void write_force (void);
< void write_timings (void);
< void wvfn_residual(STATE *states);
< REAL rand0 (long *idum);
< 
< void mg_restrict (REAL *full, REAL *half, int dimx, int dimy, int dimz);
< void mg_prolong (REAL *full, REAL *half, int dimx, int dimy, int dimz);
< void gather_psi (REAL *tmp_psiR, REAL *tmp_psiI, STATE *sp, int tid);
< void scatter_psi (REAL *tmp_psiR, REAL *tmp_psiI, STATE *sp, int tid);
< void get_milliken (STATE *states);
< 
< #ifdef SMP
< void create_threads (STATE *states);
< void start_threads (int action);
< void wait_for_threads (void);
< void thread_spinlock (int *lockptr);
< void *thread_scheduler (void *);
< void thread_dispatch (SCF_THREAD_CONTROL *s, int job);
< void ortho1_smp (SCF_THREAD_CONTROL *s);
< void ortho2_smp (SCF_THREAD_CONTROL *s);
< void get_rho_smp (SCF_THREAD_CONTROL *s);
< void sort_psi_smp (SCF_THREAD_CONTROL *s);
< void subdiag1_smp (SCF_THREAD_CONTROL *s);
< void subdiag2_smp (SCF_THREAD_CONTROL *s);
< #endif
< 
< void bandstructure( STATE *states, REAL *vxc, REAL *vh, REAL *vnuc );
< void output_wave( STATE *states, int kpt, int fhand );
< 
< void QMD_sem_init (QMD_sem_t *sem);
< void QMD_sem_destroy (QMD_sem_t *sem);
< void QMD_sem_wait (QMD_sem_t *sem);
< void QMD_sem_post (QMD_sem_t *sem);
< 
< /* Blas wrappers */
< void QMD_saxpy (int n, REAL alpha, REAL *x, int incx, REAL *y, int incy);
< void QMD_sscal (int n, REAL alpha, REAL *x, int incx);
< void QMD_scopy (int n, REAL *x, int incx, REAL *y, int incy);
< REAL QMD_sdot (int n, REAL *x, int incx, REAL *y, int incy);
< 
< 
< 
< int get_index (ION *iptr, int *Aix, int *Aiy, int *Aiz,
<                int *ilow, int *ihi, int *jlow, int *jhi, int *klow,
<                int *khi, int cdim, int pxgrid, int pygrid, int pzgrid,
<                int nxgrid, int nygrid, int nzgrid,
<                REAL *lxcstart, REAL *lycstart, REAL *lzcstart);
< 
< REAL linint (REAL *y, REAL rv, REAL invdr);
< void my_barrier (void);
< 
< 
< #ifdef UNICOS_T3E
< #define exit globalexit
< #endif
< 
< /* Conversion between crystal and cartesian coordinate prototypes */
< void latgen (int *ibrav, REAL *celldm, REAL *A0I, REAL *A1I, REAL *A2I,
<              REAL *OMEGAI, int *flag);
< void recips (void);
< void to_cartesian (REAL crystal[], REAL cartesian[]);
< void to_crystal (REAL crystal[], REAL cartesian[]);
< REAL metric (REAL *crystal);
< 
< /* Md run types */
< void quench (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc, REAL *rho,
<              REAL *rhocore, REAL *rhoc);
< void quench_spin (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc, REAL *rho,
<              REAL *rho_oppo, REAL *rhocore, REAL *rhoc);
< void fastrlx (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<               REAL *rho, REAL *rhocore, REAL *rhoc);
< void fastrlx_spin (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<               REAL *rho, REAL *rho_oppo, REAL *rhocore, REAL *rhoc);
< void neb_relax (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<               REAL *rho, REAL *rhocore, REAL *rhoc);
< void cdfastrlx (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<                 REAL *rho, REAL *rhocore, REAL *rhoc);
< void moldyn (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<              REAL *rho, REAL *rhoc, REAL *rhocore);
< void dx (STATE *states, P0_GRID *vxc, P0_GRID *vh, P0_GRID *vnuc,
<          P0_GRID *rho, P0_GRID *rhoc);
< void psidx (STATE *states, P0_GRID *vxc, P0_GRID *vh, P0_GRID *vnuc,
<             P0_GRID *rho, P0_GRID *rhoc);
< void cholesky (REAL *a, int n);
< 
< 
< /*the function for softpseudopotential*/
< void aainit (int lli, int mix, int lx, int mx, int nlx, double ap[][9][9],
<              int lpx[][9], int lpl[][9][9]);
< REAL app_cil1 (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_bcc (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_fcc (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_hex (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                    REAL gridhx, REAL gridhy, REAL gridhz);
< REAL app_cil1_ortho (REAL *a, REAL *b, int dimx, int dimy, int dimz,
<                      REAL gridhx, REAL gridhy, REAL gridhz);
< void app_nl_psi (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int flag, int kidx, int tid);
< void app_nl_eig (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int flag, int kidx, int tid);
< void app_ns_psi (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int kidx, int tid);
< void app_ns_eig (REAL *psiR, REAL *psiI, REAL *workR, REAL *workI,
<                  int state, int kidx, int tid);
< void get_ddd (REAL *veff);
< void get_nlop_d (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_nlop_p (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_nlop_s (ION *iptr, REAL *rtptr, int ip, int icount, int *dvec);
< void get_QI (void);
< void get_qqq (void);
< void get_rho (STATE * states, REAL * rho, REAL * rhocore);
< void init_psp (void);
< void init_qfunct (void);
< void mg_eig_state (STATE *sp, int tid, REAL *vtot_psi);
< void ortho_full (STATE *states);
< void ortho (STATE *states, int kpt);
< REAL qval (int ih, int jh, REAL r, REAL invdr, REAL *ptpr, int *nhtol,
<            int *nhtom, int *indv, REAL *ylm, REAL ap[][9][9], int lpx[][9],
<            int lpl[][9][9], SPECIES *sp);
< void scf (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<           REAL *rho, REAL *rhocore, REAL *rhoc, int *CONVERGENCE);
< void scf_spin (STATE *states, REAL *vxc, REAL *vh, REAL *vnuc,
<           REAL *rho,REAL *rho_oppo, REAL *rhocore, REAL *rhoc, int *CONVERGENCE);
< 
< #if GAMMA_PT
< void subdiag_gamma (STATE *states, REAL *vh, REAL *vnuc, REAL *vxc);
< #else
< void subdiag_nongamma (STATE * states, REAL * vh, REAL * vnuc, REAL * vxc);
< #endif
< 
< void ylmr2 (double *r, double *ylm);
< REAL gcutoff (REAL g1, REAL gcut, REAL width);
< void rft1 (REAL cparm, REAL *f, REAL *r, REAL *ffil, REAL *rab,
<            int rg_points, int lval, REAL dr, REAL width, int lrg_points);
< void norm_psi1 (STATE *sp, int istate, int kpt);
< void ortho_get_coeff (STATE * sp1, STATE * sp2, int ist1, int ist2, int kidx, REAL *cR, REAL *cI);
< void update_waves (STATE * sp1, STATE * sp2, int ist1, int ist2, int kidx, REAL cR, REAL cI);
< REAL get_QnmL (int idx, int ltot, REAL r, SPECIES *sp);
< 
< /*force for softpseudopotential*/
< void force (REAL *rho, REAL *rhoc, REAL *vh, REAL *vxc, REAL *vnuc,
<             STATE *states);
< 
< void force_spin (REAL *rho, REAL *rho_oppo, REAL *rhoc, REAL *vh, REAL *vxc, REAL *vnuc,
<             STATE *states);
< 
< void iiforce (void);
< void lforce (REAL *rho, REAL *vh);
< void nlforce1 (REAL *veff);
< void get_gamma (REAL *gammaR, ION *iptr, int nh);
< void partial_gamma (int ion, REAL *par_gammaR, REAL *par_omegaR, ION *iptr,
<                     int nh, REAL *newsintR_x, REAL *newsintR_y,
<                     REAL *newsintR_z, REAL *newsintI_x, REAL *newsintI_y,
<                     REAL *newsintI_z);
< void partial_betaxpsi (int ion, fftwnd_plan p2, REAL *newsintR_x,
<                        REAL *newsintR_y, REAL *newsintR_z,
<                        REAL *newsintI_x, REAL *newsintI_y,
<                        REAL *newsintI_z, ION *iptr);
< void nlforce1_par_Q (REAL *veff, REAL *gamma, int ion, ION *iptr, int nh,
<                      REAL *forces);
< void nlforce1_par_gamma (REAL *par_gamma, int ion, int nh);
< void nlforce1_par_omega (REAL *par_omega, int ion, ION *iptr, int nh);
< void partial_QI (int ion, REAL *QI_R, ION *iptr);
< void qval_R (int ih, int jh, REAL r, REAL *x, REAL *qlig, REAL *drqlig,
<              REAL invdr, int *nhtol, int *nhtom, int *indv, REAL *ylm,
<              REAL *ylm_x, REAL *ylm_y, REAL *ylm_z, REAL ap[][9][9],
<              int lpx[][9], int lpl[][9][9], REAL *Q_x, REAL *Q_y,
<              REAL *Q_z, SPECIES *sp);
< void ylmr2_x (double *r, double *ylm_x);
< void ylmr2_y (double *r, double *ylm_y);
< void ylmr2_z (double *r, double *ylm_z);
< void nlccforce (REAL *rho, REAL *vxc);
< REAL get_ve_nl (STATE *sta, int istate);
< void pack_rho_ctof (REAL *rhoc, REAL *rhof);
< void bspline_interp_full (REAL *rho, REAL *rho_f);
< void get_vtot_psi (REAL *vtot_psi, REAL *vtot);
< void betaxpsi (STATE *states);
< void betaxpsi1 (STATE *states, int kpt);
< void assign_weight (SPECIES *sp, int ion, fftw_complex *beptr,
<                     REAL *rtptr);
< void assign_weight2 (int nldim, int ion, REAL *beptr, REAL *rtptr);
< void pack_gftoc (SPECIES *sp, fftw_complex *gwptr, fftw_complex *gbptr);
< void debug_write_rho_z (REAL *rhoz);
< void print_density_z_direction (int grid_x, int grid_y, REAL *density,
<                                 int px0_grid, int py0_grid, int pz0_grid,
<                                 REAL zside);
< void get_derweight (int ion, REAL *beta_x, REAL *beta_y, REAL *beta_z,
<                     ION *iptr, fftwnd_plan p2);
< void partial_beta_fdiff (fftw_complex *beptr, int nldim, REAL *beta_x,
<                          REAL *beta_y, REAL *beta_z);
< 
< void mulliken (STATE *states);
< REAL ylm(int l, REAL *r);
< int listlen (FILE * fh, char *id);
< int del_space (FILE * fh, int *tchr, int isdata);
< void norm_psi1_parallel (STATE * sp, int istate, int kidx);
< void print_matrix(double *b, int n, int ldb);
< void sl_init(int *ictxt, int size);
< void sl_exit(int ictxt);
< void set_desca(int *desca, int *ictxt, int *size);
< void distribute_mat(int *desca, double *bigmat, double *dismat, int *size);
< void matinit(int *desca, double *dismat, double *globmat, int size);
< void print_distribute_mat(double *dismat, int *desca, int size);
< void init_efield (REAL * vnuc);
< void pulay(int step, int N, double *xm, double *fm, int NsavedSteps, int preconditioning);
< 
< 
< /* Some stuff for timing and performance measurements */
< #define TOTAL_TIME (0)
< #define ORTHO_TIME (1)
< //#define NL_TIME (2)
< //#define NS_TIME (3)
< #define EIG_TIME (4)
< #define IMAGE_TIME (5)
< //#define APPCIL_TIME (6)
< //#define APPCIR_TIME (7)
< #define RESTRICT_TIME (8)
< #define EXPAND_TIME (9)
< #define PACK_TIME (10)
< #define INIT_TIME (11)
< #define HARTREE_TIME (12)
< #define DIAG_TIME (13)
< #define LFORCE_TIME (14)
< #define NLFORCE_TIME (15)
< #define APPGRAD_TIME (16)
< #define GATHER_TIME (17)
< #define MG_EIGTIME (18)
< #define INTERPOLATION_TIME (19)
< #define RHO_TIME (20)
< #define FORCE_TIME (21)
< #define SCF_TIME (22)
< //#define MD_LOOP (23)
< #define NLCCFORCE_TIME (24)
< #define IIFORCE_TIME (25)
< #define MG_EIG_NLS_TIME (26)
< #define MG_EIG_APPCIL_TIME (27)
< #define MG_EIG_APPCIR_TIME (28)
< #define MG_EIG_TRADE_TIME (29)
< #define DIAG_NL_TIME (30)
< #define DIAG_APPCIL_TIME (31)
< #define DIAG_APPCIR_TIME (32)
< #define GET_TE_XC_TIME (33)
< #define GET_TE_II_TIME (34)
< #define GET_TE_TIME (35)
< #define SCF_XC_TIME (36)
< #define INTERP_SETUP_TIME (37)
< #define INTERP_EVAL_TIME (38)
< #define DIAG_SUBDIAG1_TIME (39)
< #define DIAG_MATRIX_TIME (40)
< #define DIAG_WAVEUP_TIME (41)
< #define DIAG_SUBDIAG1_LOOP_TIME (42)
< #define DIAG_APP_A (43)
< #define DIAG_APP_S (44)
< #define DIAG_APP_B (45)
< #define DIAG_DGEMM (46)
< #define DIAG_GENVPSI_TIME (47)
< #define DIAG_GLOB_SUMS (48)
< #define DIAG_BETAXPSI (49)
< #define ALLOC_TIME (50)
< #define ORTHO_BETAXPSI (51)
< #define ORTHO_NORM_PSI (52)
< #define ORTHO_NEW_PSI (53)
< #define ORTHO_GET_COEFF (54)
< #define ORTHO_GLOB_SUM (55)
< #define ORTHO_UPDATE_WAVES (56)
< #define DIAG_APPCIR_TIME2 (57)
< #define MG_EIG_GENVPSI_TIME (58)
< #define MG_EIG_EIGVALUE_TIME (59)
< #define MG_EIG_APPSMOOTH_TIME (60)
< #define MG_EIG_MGRIDSOLV_TIME (61)
< #define MG_EIG_PACK_TIME (62)
< #define DIAG_NLS_TIME (63)
< #define PREINIT_TIME (64)
< #define FINISH_TIME (65)
< #define DIAG_SCALAPACK_INIT (66)
< #define DIAG_DISTMAT (67)
< #define REAL_SUM_ALL_TIME (68)
< #define GLOBAL_SUMS_TIME (69)
< #define DIAG_BCAST_EIGS (70)
< #define READ_PSEUDO_TIME 71
< #define READ_CONTROL_TIME 72
< 
< #define LAST_TIME (80)
< 
< 
< /* Occupation flags */
< #define OCC_NONE 0
< #define OCC_FD 1
< #define OCC_GS 2
< #define OCC_EF 3
< 
< 
< /* SMP directives for the threads */
< #define     SMP_EIG       1
< #define     SMP_ORTHO1    2
< #define     SMP_ORTHO2    3
< #define     SMP_GET_RHO   4
< #define     SMP_SORT_PSI  5
< #define     SMP_SKIP      6
< #define     SMP_DIAG1     7
< #define     SMP_DIAG2     8
< #define     SMP_NLFORCE   9
< #define     SMP_GETNLOP  10
< 
< 
< /* Crystal lattice types */
< /** Simple cubic lattice type.
<  *  @doc Set input file value = 1 */
< #define CUBIC_PRIMITIVE 	1
< 
< /** Face centered cubic lattice type. 
<  *  @doc Set input file value = 2 */
< #define CUBIC_FC		2
< 
< /** Bodycentered cubic lattice type. 
<  *  @doc Set input file value = 3 */
< #define CUBIC_BC		3
< 
< /** Hexagonal lattice type. 
<  *  @doc Set input file value = 4 */
< #define HEXAGONAL		4
< 
< #define TRIGONAL_PRIMITIVE	5
< #define TETRAGONAL_PRIMITIVE	6
< #define TETRAGONAL_BC           7
< 
< /** Orthorhombic lattice type. 
<  *  @doc Set input file value = 8 */
< #define ORTHORHOMBIC_PRIMITIVE  8
< 
< #define ORTHORHOMBIC_BASE_CENTRED 9
< #define ORTHORHOMBIC_BC         10
< #define ORTHORHOMBIC_FC 11
< #define MONOCLINIC_PRIMITIVE 12
< #define MONOCLINIC_BASE_CENTRED 13
< #define TRICLINIC_PRIMITIVE 14
< 
< /* The real or imaginary part of a wavefunction */
< #define PSI_REAL     0
< #define PSI_IMAG     1
< 
< 
< 
< 
< 
< 
1987a88,93
> 
> /* Custom types used in the code*/
> #include "typedefs.h"
> 
> /*Prototypes for function calls*/
> #include "prototypes.h"
2c2
<  **    $Id: my_scalapack.h 1004 2008-08-09 18:37:21Z froze $    **
---
>  **    $Id: my_scalapack.h 1220 2011-01-27 23:59:08Z miro $    **
34c34
< #endif
---
> #else
36c36
< #if  ( LINUX ||  IRIX || XT3 )
---
> #ifdef  LINUX
54a55
> #endif
2c2
<  *  **    $Id: input.h 1123 2010-05-19 20:03:04Z froze $    **
---
>  *  **    $Id: input.h 1212 2011-01-25 18:52:03Z froze $    **
94a95
> int      sstripcmnt (char *string, const char delim);
2c2
<  **    $Id: blas.h 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: blas.h 1220 2011-01-27 23:59:08Z miro $    **
45c45
< #if (LINUX || IRIX || XT3)
---
> #ifdef LINUX 
67d66
< #  define               exchlsd         exchlsd_
83c82,83
< #elif AIX
---
> #else
> #ifdef AIX
100,130c100
< #elif UNICOS_T3E
< 
< #  define		saxpy		SAXPY
< #  define		scopy   	SCOPY
< #  define		sdot    	SDOT
< #  define		sscal   	SSCAL
< #  define		snrm2   	SNRM2
< #  define		sswap   	SSWAP
< #  define		spotrf  	SPOTRF
< #  define		spotri  	SPOTRI
< #  define		ssyev   	SSYEV
< #  define		global_sums 	GLOBAL_SUMS
< #  define		ilaenv  	ILAENV
< #  define		app_del2f  	APP_DEL2F
< #  define		xbecke    	XBECKE
< #  define		corlyp_f90      corlyp_f90_
< #  define		exch      	EXCH
< #  define		corlsd    	CORLSD
< #  define               exchlsd         EXCHLSD
< #  define		corgga    	CORGGA
< #  define		corpbe    	CORPBE
< #  define		exchpbe   	EXCHPBE
< #  define		symrho    	SYMRHO
< #  define		symmetry  	SYMMETRY
< #  define		fsymforces 	FSYMFORCES
< #  define       cpotrf     	CPOTRF
< #  define       cpotri     	CPOTRI
< #  define       cheev      	CHEEV
< #  define       fgram      	FGRAM
< #  define		latgen 	   	LATGEN
< 
---
> #endif
152d121
< void exchlsd (REAL *rho, REAL * ex, REAL * vx );
159a129
> void cpotrf (char *uplo, int *n, REAL * a, int *lda, int *info);
180,184d149
< 
< 
< #ifndef UNICOS_T3E
< void cpotrf (char *uplo, int *n, REAL * a, int *lda, int *info);
< #endif
2c2
<  **    $Id: macros.h 1170 2011-01-06 21:47:13Z yanli $    **
---
>  **    $Id: macros.h 1143 2010-09-24 17:42:02Z froze $    **
32,34c32
< //#define dprintf( format, args...) fprintf (stderr, "\n#WARNING from IMG PE %d in IMG %d  of grid rank %d of spin %d:    \t"format"\n", pct.imgpe, pct.thisimg, pct.thispe, pct.thisspin,  ##args), fflush(NULL)
< #define dprintf( format, args...) fprintf (stderr, "\ngrid rank %d of spin %d:    \t"format"\n", pct.thispe, pct.thisspin,  ##args), fflush(NULL)
< 
---
> #define dprintf( message... ) fprintf( stderr, message )
46,47c44
< 	 ((pct.imgpe == 0) ? fprintf( ct.logfile, message ): 0)
< 	
---
> 	 ((pct.thispe == 0) ? fprintf( ct.logfile, message ): 0)
51,52c48,49
<     fprintf (stderr, "\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisimg+1, __FILE__, __LINE__, pct.thispe), \
<     printf ("\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisimg+1, __FILE__, __LINE__, pct.thispe), \
---
>     fprintf (stderr, "\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisgrp+1, __FILE__, __LINE__, pct.thispe), \
>     printf ("\nExit from PE %d of image %d, in file %s, line %d\nPE %d Error Message is: ", pct.thispe, pct.thisgrp+1, __FILE__, __LINE__, pct.thispe), \
2c2
<  **    $Id: params.h 1062 2009-08-11 20:13:24Z froze $    **
---
>  **    $Id: params.h 1161 2010-10-26 23:18:51Z froze $    **
177,185d176
< 
< 
< #ifdef SMP
< #  define         PHYS_PES        1
< #else
< #  define         PHYS_PES        (NPES)
< #endif
< 
< 
2c2
<  **    $Id: const.h 1123 2010-05-19 20:03:04Z froze $    **
---
>  **    $Id: const.h 1241 2011-02-01 23:45:44Z miro $    **
145a146,284
> 
> 
> 
> /* Some stuff for timing and performance measurements */
> #define TOTAL_TIME (0)
> #define ORTHO_TIME (1)
> //#define NL_TIME (2)
> //#define NS_TIME (3)
> #define EIG_TIME (4)
> #define IMAGE_TIME (5)
> //#define APPCIL_TIME (6)
> //#define APPCIR_TIME (7)
> #define RESTRICT_TIME (8)
> #define EXPAND_TIME (9)
> #define PACK_TIME (10)
> #define INIT_TIME (11)
> #define HARTREE_TIME (12)
> #define DIAG_TIME (13)
> #define LFORCE_TIME (14)
> #define NLFORCE_TIME (15)
> #define APPGRAD_TIME (16)
> #define GATHER_TIME (17)
> #define MG_EIGTIME (18)
> #define INTERPOLATION_TIME (19)
> #define RHO_TIME (20)
> #define FORCE_TIME (21)
> #define SCF_TIME (22)
> //#define MD_LOOP (23)
> #define NLCCFORCE_TIME (24)
> #define IIFORCE_TIME (25)
> #define MG_EIG_NLS_TIME (26)
> #define MG_EIG_APPCIL_TIME (27)
> #define MG_EIG_APPCIR_TIME (28)
> #define MG_EIG_TRADE_TIME (29)
> #define DIAG_NL_TIME (30)
> #define DIAG_APPCIL_TIME (31)
> #define DIAG_APPCIR_TIME (32)
> #define GET_TE_XC_TIME (33)
> #define GET_TE_II_TIME (34)
> #define GET_TE_TIME (35)
> #define SCF_XC_TIME (36)
> #define INTERP_SETUP_TIME (37)
> #define INTERP_EVAL_TIME (38)
> #define DIAG_SUBDIAG1_TIME (39)
> #define DIAG_MATRIX_TIME (40)
> #define DIAG_WAVEUP_TIME (41)
> #define DIAG_SUBDIAG1_LOOP_TIME (42)
> #define DIAG_APP_A (43)
> #define DIAG_APP_S (44)
> #define DIAG_APP_B (45)
> #define DIAG_DGEMM (46)
> #define DIAG_GENVPSI_TIME (47)
> #define DIAG_GLOB_SUMS (48)
> #define DIAG_BETAXPSI (49)
> #define ALLOC_TIME (50)
> #define ORTHO_BETAXPSI (51)
> #define ORTHO_NORM_PSI (52)
> #define ORTHO_NEW_PSI (53)
> #define ORTHO_GET_COEFF (54)
> #define ORTHO_GLOB_SUM (55)
> #define ORTHO_UPDATE_WAVES (56)
> #define DIAG_APPCIR_TIME2 (57)
> #define MG_EIG_GENVPSI_TIME (58)
> #define MG_EIG_EIGVALUE_TIME (59)
> #define MG_EIG_APPSMOOTH_TIME (60)
> #define MG_EIG_MGRIDSOLV_TIME (61)
> #define MG_EIG_PACK_TIME (62)
> #define DIAG_NLS_TIME (63)
> #define PREINIT_TIME (64)
> #define FINISH_TIME (65)
> #define DIAG_SCALAPACK_INIT (66)
> #define DIAG_DISTMAT (67)
> #define REAL_SUM_ALL_TIME (68)
> #define GLOBAL_SUMS_TIME (69)
> #define DIAG_BCAST_EIGS (70)
> #define READ_PSEUDO_TIME 71
> #define READ_CONTROL_TIME 72
> 
> #define LAST_TIME (80)
> 
> 
> /* Occupation flags */
> #define OCC_NONE 0
> #define OCC_FD 1
> #define OCC_GS 2
> #define OCC_EF 3
> 
> 
> /* SMP directives for the threads */
> #define     SMP_EIG       1
> #define     SMP_ORTHO1    2
> #define     SMP_ORTHO2    3
> #define     SMP_GET_RHO   4
> #define     SMP_SORT_PSI  5
> #define     SMP_SKIP      6
> #define     SMP_DIAG1     7
> #define     SMP_DIAG2     8
> #define     SMP_NLFORCE   9
> #define     SMP_GETNLOP  10
> 
> 
> /* Crystal lattice types */
> /** Simple cubic lattice type.
>  *  @doc Set input file value = 1 */
> #define CUBIC_PRIMITIVE 	1
> 
> /** Face centered cubic lattice type. 
>  *  @doc Set input file value = 2 */
> #define CUBIC_FC		2
> 
> /** Bodycentered cubic lattice type. 
>  *  @doc Set input file value = 3 */
> #define CUBIC_BC		3
> 
> /** Hexagonal lattice type. 
>  *  @doc Set input file value = 4 */
> #define HEXAGONAL		4
> 
> #define TRIGONAL_PRIMITIVE	5
> #define TETRAGONAL_PRIMITIVE	6
> #define TETRAGONAL_BC           7
> 
> /** Orthorhombic lattice type. 
>  *  @doc Set input file value = 8 */
> #define ORTHORHOMBIC_PRIMITIVE  8
> 
> #define ORTHORHOMBIC_BASE_CENTRED 9
> #define ORTHORHOMBIC_BC         10
> #define ORTHORHOMBIC_FC 11
> #define MONOCLINIC_PRIMITIVE 12
> #define MONOCLINIC_BASE_CENTRED 13
> #define TRICLINIC_PRIMITIVE 14
> 
> /* The real or imaginary part of a wavefunction */
> #define PSI_REAL     0
> #define PSI_IMAG     1
> 
> 
> 
12c12
< MODULES = Common Input Spin Spin/XC
---
> MODULES = Common Input ../Common/*
14,16c14
< FFILES := $(foreach MODULE, $(MODULES), $(wildcard $(MODULE)/*.f))   
< #F90FILES := $(foreach MODULE, $(MODULES), $(wildcard $(MODULE)/*.f90))   # include some fortran 90
< 
---
> FFILES := $(foreach MODULE, $(MODULES), $(wildcard $(MODULE)/*.f))
23,25c21,22
< FOBJECTS = $(FFILES:.f=.o)  # include some fortran 90
< #F90OBJECTS = $(F90FILES:.f90=.o)
< OBJECTS = $(COBJECTS) $(FOBJECTS) #$(F90OBJECTS)
---
> FOBJECTS = $(FFILES:.f=.o)
> OBJECTS = $(COBJECTS) $(FOBJECTS)
34c31
< CF = gfortran  #pgf90 #ftn
---
> CF = ftn
49c46
< rmg: Headers/svnrev.h $(OBJECTS) $(FOBJECTS) $(COBJECTS) #$(F90OBJECTS)
---
> rmg: Headers/svnrev.h $(COBJECTS) $(FOBJECTS)
54,55c51,52
< Headers/svnrev.h: SvnRev/svnrev $(CFILES) $(FFILES) $(HFILES) $(MFILES) #$(F90FILES)
< 	SvnRev/svnrev $(CFILES) $(FFILES)  $(F90FILES) $(HFILES) $(MFILES)
---
> Headers/svnrev.h: SvnRev/svnrev $(CFILES) $(FFILES) $(HFILES) $(MFILES)
> 	SvnRev/svnrev $(CFILES) $(FFILES) $(HFILES) $(MFILES)
